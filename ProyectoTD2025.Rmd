---
title: "ProyectoTD2025"
author:
- Andrea Fu Castelló Sala
- Sergio Del Carme Moreno
- María Martínez Marí
- Jorge Navarro Rodríguez
- Iván Pérez Alonso
- Edurne Serigó Troyano
date: "`r Sys.Date()`"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)

# Configurar nombres en español para gráficos
options(OutDec = ",", digits = 2)
```

```{r}
## Cargamos las librerias que vamos a usar
library(pdftools)
library(tidyverse)
library(dplyr)
library(stringr)
library(ggplot2)
library(knitr)
```

## Introducción

Mercadona y otros supermecados como Lidl, Dia y Comsum han implantado el ticket electrónico y los usuarios que lo deseen pueden recibirlo como documento pdf en su correo electrónico, en lugar de hacerlo en papel.

Como alumnos del GCD nos plantemos el siguiente objetivo:

Queremos desarrollar un programa que permita analizar los tickets para realizar un seguimiento de evolución de precios, compras más habituales, productos más consumidos, supermercado habitual, hora de compra, etc.

Dado que el formato no es el mismo nos vamos a centrar en tickets de Mercadona.

Con este proyecto se espera desarrollar una herramienta capaz de leer y analizar automáticamente tickets de compra de Mercadona, extraídos en formato PDF, para obtener información útil sobre los hábitos de consumo.

## Material y métodos

Para este proyecto se ha utilizado un conjunto de tickets de compra proporcionados en formato PDF. Todos los tickets pertenecen, como hemos comentado antes, a supermercados Mercadona.

El análisis de datos se realiza utilizando el lenguaje de programación R.

Como sabemos, la librería `pdftools` y la función `pdf_text` sirven para cargar el contenido del ticket en un vector de texto. Por lo tanto, los tickets serán leídos uno a uno utilizando la función `pdf_text()` de la librería `pdftools`, que permite convertir el contenido del PDF en texto plano. A partir de ese texto, se ha extraído:

-   Encabezado (previo a productos) FIJO
-   Parte final (después del Total).
-   Si hay aparcamiento o no (línea extra)
-   Productos: · Venta por unidades · Venta al peso, FRUTA y VERDURA · Venta al peso, PESCADO · Venta LISTO COMER (No hay en los tickets proporcionados)

## Importación de datos

A continuacón realizaremos la importación de datos para cargar los tickets en pdf de mercadona:

Primero cargamos todos los datos.

```{r}

ruta_tickets<- 'data/'
archivos_pdf <- list.files(path = ruta_tickets, pattern = "Mercadona", 
                           full.names = TRUE, recursive = TRUE)

# Leer todos los archivos y construir un data frame
df_lineas <- do.call(rbind, lapply(archivos_pdf, function(archivo) {
  paginas <- pdf_text(archivo)
  texto <- paste(paginas, collapse = "\n")       # Unir todas las páginas
  lineas <- unlist(strsplit(texto, "\n"))        # Separar en líneas
  
  # Crear un data.frame con nombre del archivo, número de línea y texto
  data.frame(
    archivo = basename(archivo),
    linea = seq_along(lineas),
    texto = lineas,
    stringsAsFactors = FALSE
  )
}))

kable(head(df_lineas,52),caption= "Tabla de tickets de mercadona") #Se muestra el df de los tickets del mercadona
```

## Preguntas planteadas por el profesor

1.  ¿Cuáles son los 5 productos, de los vendidos por unidades, con más ventas? ¿Cuántas unidades de cada uno se han vendido?

```{r}

# Filtrar líneas que comienzan con un número (cantidad)
df_productos <- df_lineas %>% filter(str_detect(texto, "^\\d+\\s" # Esto quiere decir que del texto del ticket sacamos todo aquello que empiece por (^: inicio de linea, \\d+: \\d(me coge los digitos) y + (me coge uno o mas digitos, depende de cuantos haya) y \\s: al final tenga espacios en blanco (+: uno o varios)
                    )) %>%
  
# Extraer partes específicas de cada línea (con str_match): cantidad, nombre del producto, y precio
  mutate(
    matches = str_match(texto, "^(\\d+)\\s+(.*?)\\s+(\\d+,\\d{2})\\s+(\\d+,\\d{2})?$" # Esto quiere decir que del texto del ticket sacamos todo aquello que empiece por (^: comienzo de linea, (\\d+): una o mas cifras(cantidad),  \\s+: uno o mas espacios en blanco, (.*?): me dice el nombre del producto, \\s+: uno o mas espacios en blanco, (\\d+,\\d{2}): me coje el precio por unidades, \\s+: uno o mas espacios, (\\d+,\\d{2})?: me coje el importe total y, por ultimo $:final de linea)
                        ),
# Crear columnas a partir de los grupos extraídos
    cantidad = as.numeric(matches[, 2]),
    producto = str_trim(matches[, 3])
  ) %>%
  filter(!is.na(cantidad), !is.na(producto))

# Agrupar y sumar las cantidades por producto (unidades vendidas por producto)
top_5_productos <- df_productos %>%
  group_by(producto) %>%
  summarise(unidades_vendidas = sum(cantidad), .groups = "drop") %>%

# Ordenar y obtener el top 5 de productos mas vendidos  
  arrange(desc(unidades_vendidas)) %>%
  slice_head(n = 5)

#Mostrar el resultado
print(top_5_productos)

# Como podemos observar, los cinco productos más vendidos por unidades son: leche desnatada con calcio (22 unidades), barra campesina(12 unidades), chapata cristal(12 unidades), garbanzo m.cocido (12 unidades) y leche desnatada sin lactosa (12 unidades)

```

2.  Si consideramos la categoría de FRUTAS Y VERDURAS. Cuáles son los 5 productos más vendidos? ¿Cuántos kilos se han vendido de cada uno de estos productos?

```{r}

# Lista de palabras clave de frutas y verduras
productos_frutas_verduras <- c("manzana", "plátano", "naranja", "fresa", "pera", "kiwi", "sandía", "melon", "tomate", "lechuga", "pepino", "pimiento", "berenjena", "calabacín", "ajo", "cebolla", "zanahoria", "patata", "aguacate", "brocoli", "col", "apio", "alcachofa", "espárrago", "frambuesa", "cereza", "mango", "limón", "mandarina")

# Buscar líneas del df_lineas que contengan alguna de estas palabras
frutas_verduras <- grep(paste(productos_frutas_verduras, collapse = "|"), tolower(df_lineas$texto))

# Crear un nuevo data.frame para guardar resultados
resultados <- data.frame(producto = character(), cantidad_kg = numeric(), stringsAsFactors = FALSE)

# Recorremos cada línea que contiene una fruta o verdura
for (i in frutas_verduras) {
  linea_producto <- df_lineas$texto[i]
 #Extraer nombre del producto
  producto <- gsub("\\s*\\d+\\s*(kg|KG).*" # Esto quiere decir que del texto del ticket sacamos todo aquello que empiece por (\\s*: puede ser que tenga o no espacios en blanco, \\d+: uno o mas digitos, \\s*: espacios opcionales entre el numero y el kilo, kg: que sean kilos y .*:quiere decir que puede ser que detras tenga otra cosa)
                   , "", linea_producto)  # Limpia el nombre del producto

  # Extraer la cantidad de la misma línea
  match_misma_linea <- regmatches(linea_producto, regexpr("\\d+[.,]?\\d*\\s*(kg|KG)" # Esto quiere decir que del texto del ticket sacamos todo aquello que empiece por (\\d+:uno o mas digitos, [.,]?: despues hay una coma o punto y coma, \\d*: seguido de cero o algunos digitos, \\s*: despues cero o algun espacio y kg: acabado en kg)
                                                          , linea_producto, ignore.case = TRUE))
  
  if (length(match_misma_linea) > 0) {
    cantidad <- as.numeric(gsub(",", ".", gsub(" kg", "", tolower(match_misma_linea))))
  } 
  # Si no hay kilos en esa línea, intenta mirar la línea siguiente
  else if (i + 1 <= nrow(df_lineas)) {
    # Revisar la línea siguiente
    linea_siguiente <- df_lineas$texto[i + 1]
    match_siguiente_linea <- regmatches(linea_siguiente, regexpr("\\d+[.,]?\\d*\\s*(kg|KG)" # Es exactamente lo mismo de antes 
                                                                 , linea_siguiente, ignore.case = TRUE))
    
    if (length(match_siguiente_linea) > 0) {
      cantidad <- as.numeric(gsub(",", ".", gsub(" kg", "", tolower(match_siguiente_linea))))
    } else {
      cantidad <- NA
    }
  } else {
    cantidad <- NA
  }
  
  # Añadir los datos a la tabla
  resultados <- rbind(resultados, data.frame(producto = producto, cantidad_kg = cantidad, stringsAsFactors = FALSE))
}

# Limpieza robusta del nombre del producto
resultados$producto <- toupper(resultados$producto)                     # Todo a mayúsculas
resultados$producto <- gsub("^[^A-Z]*" # Esto quiere decir que del texto del ticket sacamos todo aquello que empiece por (^: inicio de linea, [^A-Z]: seguido de cualquier caracter que no sea una letra mayuscula de la A a la Z, *: puede ser que haya o no alguna repeticion de este patron)
                            , "", resultados$producto)        # Elimina cualquier cosa que no sea letra al inicio
resultados$producto <- gsub("\\s+" # Esto quiere decir que del texto del ticket sacamos todo aquello que empiece por (\\s+: uno o mas espacios en blanco)
                            , " ", resultados$producto)           # Reemplaza múltiples espacios por uno solo
resultados$producto <- trimws(resultados$producto)                      # Quita espacios delante y detrás


# Agrupar y resumir por producto ya normalizado
top_5_frutas_verduras <- resultados %>%
  filter(!is.na(cantidad_kg)) %>%
  group_by(producto) %>%
  summarise(kilos_totales = sum(cantidad_kg)) %>%
  arrange(desc(kilos_totales))

# Ver los 5 más vendidos
head(top_5_frutas_verduras, 5)

# Los cinco productos mas vendidos de frutas y verduras son NARANJA	con 82.062Kg, PATATA con	74.800Kg, MANDARINA	con 31.186Kg, CEBOLLA con	22.000Kg y PEPINO	con 19.624Kg.
```

3.  Si consideramos la categoría de PESCADO. Cuáles son los 5 productos más vendidos? ¿Cuántos kilos se han vendido de cada uno de estos productos?

```{r}

# Lista de productos de la categoría pescado
productos_pescado <- c("merluza", "salmón", "bacalao", "atún", "lubina", "dorada", "boquerón", "anchoa", "gamba", "calamar", "sepia", "pulpo", "lenguado", "rape", "pez espada", "rodaballo", "jurel", "caballa", "sardina", "mejillón")

# Buscar líneas que contengan alguno de esos productos
pescado <- grep(paste(productos_pescado, collapse = "|"), tolower(df_lineas$texto))

# Inicializar el data.frame vacío
resultados_pescado <- data.frame(producto = character(), cantidad_kg = numeric(), stringsAsFactors = FALSE)

# Bucle para recorrer cada línea con pescado
for (i in pescado) {
  linea_producto <- df_lineas$texto[i]
  # Extraer solo el nombre del producto
  producto <- gsub("\\s*\\d+\\s*(kg|KG).*" # Esto quiere decir que del texto del ticket sacamos todo aquello que empiece por (\\s*: puede ser que tenga o no espacios en blanco, \\d+: uno o mas digitos, \\s*: espacios opcionales entre el numero y el kilo, kg: que sean kilos y .*:quiere decir que puede ser que detras tenga otra cosa)
                   , "", linea_producto)
  
  # Buscar la cantidad de kilos en la misma línea
  match_misma_linea <- regmatches(linea_producto, regexpr("\\d+[.,]?\\d*\\s*(kg|KG)", linea_producto, ignore.case = TRUE))
  
  if (length(match_misma_linea) > 0) {
    # Busca un número decimal seguido de la palabra "kg" y lo convierte en número decimal con gsub()
    cantidad <- as.numeric(gsub(",", ".", gsub(" kg", "", tolower(match_misma_linea))))
  } 
  # Si no encuentra el peso en la línea actual, mira en la siguiente
  else if (i + 1 <= nrow(df_lineas)) {
    # Revisar la línea siguiente
    linea_siguiente <- df_lineas$texto[i + 1]
    match_siguiente_linea <- regmatches(linea_siguiente, regexpr("\\d+[.,]?\\d*\\s*(kg|KG)" # Esto quiere decir que del texto del ticket sacamos todo aquello que empiece por (\\d+:uno o mas digitos, [.,]?: despues hay una coma o punto y coma, \\d*: seguido de cero o algunos digitos, \\s*: despues cero o algun espacio y kg: acabado en kg)
                                                                 , linea_siguiente, ignore.case = TRUE))
    
    if (length(match_siguiente_linea) > 0) {
      cantidad <- as.numeric(gsub(",", ".", gsub(" kg", "", tolower(match_siguiente_linea))))
    } else {
      cantidad <- NA
    }
  } else {
    cantidad <- NA
  }
  
  # Guardar en el data.frame
  resultados_pescado <- rbind(resultados_pescado, data.frame(producto = producto, cantidad_kg = cantidad, stringsAsFactors = FALSE))
}

# Normalización del texto del producto
resultados_pescado$producto <- toupper(resultados_pescado$producto)
resultados_pescado$producto <- gsub("^[^A-Z]*" # Esto quiere decir que del texto del ticket sacamos todo aquello que empiece por (^: inicio de linea, [^A-Z]: seguido de cualquier caracter que no sea una letra mayuscula de la A a la Z, *: puede ser que haya o no alguna repeticion de este patron)
                                    , "", resultados_pescado$producto)
resultados_pescado$producto <- gsub("\\s+" # Esto quiere decir que del texto del ticket sacamos todo aquello que empiece por (\\s+: uno o mas espacios en blanco)
                                    , " ", resultados_pescado$producto)
resultados_pescado$producto <- trimws(resultados_pescado$producto)

# Agrupar y sumar los kilos
top_5_pescado <- resultados_pescado %>%
  filter(!is.na(cantidad_kg)) %>%
  group_by(producto) %>%
  summarise(kilos_totales = sum(cantidad_kg)) %>%
  arrange(desc(kilos_totales))

# Mostrar los 5 productos de pescado más vendidos
head(top_5_pescado, 5)

# Los cinco productos de pescado más vendidos son rodaballo con	3.672Kg, sepia lonja con 3.584Kg, dorada con	2.934Kg, sepia fresca con	2.642Kg y sepia sucia refrig con	2.402Kg.
```

4.  Muestra mediante un gráfico de líneas como ha variado el precio por kilo de las bananas y los plátanos en los tickets disponibles, a lo largo del tiempo.

```{r figura-bananas_platanos,  fig.cap="Evolución de precio por kilo de las bananas y los plátanos"}

#Filtrar las lineas que contengan platano y banana
frutas <- df_lineas %>% filter(str_detect(tolower(texto), "platano|banana"))

#Creamos un vector con los nombres de los tickets que han combrado banana o platano
archivo_frutas <- frutas %>% select(archivo) #filtramos los nombres
archivo_frutas <- as.vector(archivo_frutas$archivo) #Convertir a vector

#Creamos un df que contiene las fechas de los tickets que han comprado platano o banana
df_fechas <- df_lineas %>% filter(linea == "5") %>% right_join(data.frame(archivo = archivo_frutas), by = "archivo") #filtramos las fechas
df_fechas <- df_fechas %>%  mutate(fecha = str_extract(texto, "\\b\\d{2}/\\d{2}/\\d{4}\\b")) %>% select(-texto) #Guardamos solo la fecha
frutas$fecha <- df_fechas$fecha #Guardamos en el vector de frutas
frutas$fecha <- as.Date(frutas$fecha, format = "%d/%m/%Y") #Convertimos en fecha

#Obtener el precio por kilo de platano y banana
filas_frutas <- which(str_detect(tolower(df_lineas$texto), "platano|banana")) #Buscamos la linea de platano o banana
filas_precio_kilo <- filas_frutas + 1 #Obtenemos la linea del precio por kilo
frutas$precio <- df_lineas %>% slice(filas_precio_kilo)%>%pull(texto) #Se agrega al df de frutas
frutas <- frutas %>%  mutate(precio_kg = str_extract(precio, "\\b\\d+,\\d{2}\\s€/kg\\b")) %>% select(-precio) #Se guarda solo el precio por kilo
frutas <- frutas %>%
  mutate(precio_kg = str_replace(precio_kg, " €/kg", "") %>%  # Elimina " €/kg"
         str_replace(",", ".") %>%     # Cambia coma por punto decimal
         as.numeric())

#Arreglar el df
frutas <- frutas %>% select(-archivo) %>% select(-linea) #Eliminar columnas sobrantes
frutas <- frutas %>%  mutate(tipo = str_extract(texto, "BANANA|PLATANO"))%>% select(-texto)

# Gráfico de líneas
ggplot(frutas, aes(x = fecha, y = precio_kg, color = tipo)) +
  geom_line() +
  geom_point() +
  labs(title = "Evolución de Precios por Kg",
       x = "Fecha",
       y = "Precio por Kg",
       color = "Tipo de Fruta")
```

5.  ¿Cuál es la procedencia de los tickets? ¿Qué ciudad/ pueblo tiene un mayor número de tickets?

```{r tabla-procedencia}
#Creamos un nuevo vector con los lugares de procedencia de los tickets
procedencia <- df_lineas %>% filter(linea == "3") %>% pull(texto) #Filtrar por el lugar
procedencia <- gsub("^\\s+|\\s+$|[0-9]", "", procedencia) #Guardar solo la ciudad/pueblo

procedencia <- as.data.frame(table(procedencia)) #Crear un df a partir de la frecuencia de cada ciudad/pueblo
procedencia <- procedencia[order(-procedencia$Freq), ] #Ordenamos de mayor a menor la frecuencia

knitr::kable(procedencia, 
             caption = "Procedencia de los tickets", 
             booktabs = TRUE)

```

Como se observa en la Tabla \@ref(tab:tabla-procedencia), las diferentes ciudades o pueblos de procedencia de los tickets, siendo Valencia la que presenta el mayor número.

6.  Muestra mediante un diagrama el número de tickets recogidos cada día de las semana. ¿Si tuvieses que cerrar un día entre semana qué día lo harías?

```{r figura-semanas, fig.cap="Tickets recogidos cada día de las semana"}
df_fechas <- df_lineas %>% filter(linea == "5") #filtrar fechas
df_fechas <- df_fechas %>%  mutate(fecha = str_extract(texto, "\\b\\d{2}/\\d{2}/\\d{4}\\b")) %>% select(-texto) #Guardamos solo la fecha
df_fechas$fecha <- as.Date(df_fechas$fecha, format = "%d/%m/%Y") #Convertir str a fecha

df_fechas$dia_semana <- weekdays(df_fechas$fecha) #Crear una nueva columna con los dias de la semana de cada fecha
dia_semana <- as.vector(df_fechas$dia_semana) #Convertir a vector solo de los dias de la semana

dia_semana <- as.data.frame(table(dia_semana)) #Convertir a df a partir de la frecuencia de cada dia de la semana
names(dia_semana)[names(dia_semana) == "dia_semana"] <- "semana"

orden_dias <- c("lunes", "martes", "miércoles", "jueves", "viernes", "sábado", "domingo")
dia_semana$semana <- factor(dia_semana$semana, levels = orden_dias)

#Diagrama
ggplot(dia_semana, aes(x = semana, y = Freq, fill = semana)) +
  geom_bar(stat = "identity") +  # "identity" usa los valores de 'Freq'
  labs(title = "Tickets recogidos cada día de las semana",
    x = "Día de la semana",
    y = "Número de tickets")
```

Como se observa en la Tabla \@ref(fig:figura-semanas), Si tuvieses que cerrar un día entre semana seria el jueves

## Preguntas planteadas por nosotros

7.  ¿Cuál es la media de ventas para cada día de la semana?

    ```{r}
    # 1. Obtener líneas con fechas
    df_fechas <- df_lineas %>%
      filter(str_detect(texto, "\\b\\d{2}/\\d{2}/\\d{4}\\b")) %>%
      mutate(
        fecha = as.Date(str_extract(texto, "\\b\\d{2}/\\d{2}/\\d{4}\\b"), format = "%d/%m/%Y")
      ) %>%
      select(archivo, fecha)

    # 2. Identificar líneas que contienen la cabecera de productos
    df_cabeceras <- df_lineas %>%
      filter(str_detect(texto, regex("Descripción.*P\\. Unit.*Importe", ignore_case = TRUE))) %>%
      select(archivo, linea) %>%
      rename(linea_inicio = linea)

    # 3. Unir cabeceras con la siguiente línea de cada archivo para marcar el inicio de productos
    df_cabeceras <- df_cabeceras %>%
      mutate(linea_inicio = as.integer(linea_inicio))

    # 4. Añadir columna para marcar si una línea es un producto (posterior a la cabecera pero antes del TOTAL o siguiente ticket)
    df_lineas_productos <- df_lineas %>%
      left_join(df_cabeceras, by = "archivo") %>%
      group_by(archivo) %>%
      mutate(es_producto = linea > linea_inicio & !str_detect(texto, regex("TOTAL|IVA|TARJETA|FACTURA|ENTRADA|SALIDA|€", ignore_case = TRUE))) %>%
      ungroup()

    # 5. Filtrar solo las líneas de productos
    df_productos <- df_lineas_productos %>%
      filter(es_producto)

    # 6. Contar número de productos por archivo
    conteo_productos <- df_productos %>%
      group_by(archivo) %>%
      summarise(num_productos = n())

    # 7. Unir con fechas
    df_final <- left_join(conteo_productos, df_fechas, by = "archivo") %>%
      mutate(dia_semana = str_to_lower(weekdays(fecha)))

    # 8. Calcular media de productos comprados por día de la semana
    media_productos_dia <- df_final %>%
      group_by(dia_semana) %>%
      summarise(media_productos = mean(num_productos)) %>%
      arrange(factor(dia_semana, levels = c("lunes", "martes", "miércoles", "jueves", "viernes", "sábado", "domingo")))

    print(media_productos_dia)


    ```

8.  ¿Cómo ha evolucionado el precio por unidad o por kilo de un producto específico a lo largo del tiempo? Hacer el gráfico de cómo varía el precio de un producto a lo largo del tiempo.

9.  ¿Cuáles son los productos menos vendidos en el conjunto de tickets disponibles?

10. En una compra, ¿cuál es el producto por unidad que se adquiere en mayor cantidad? (NO FRUTAS Y VERDURAS NI PESCADO)

```{r}
#Filtramos solo las líneas que contengan productos por unidades

#Como queremos hacer algo parecido a lo que hemos hecho en la primera pregunta podemos utilizar ese código     otra vez

df_unidades <- df_lineas %>% filter(str_detect(texto, "^\\d+\\s")) %>% separate(texto, into = c("unidades", "descripcion" ,"p.unidad", "importe"), sep = " {2,}") %>% #Separamos en unidades, descripción
  filter(descripcion != "DONACIÓN") %>% #Filtramos para que las donaciones no cuenten
  select(unidades, descripcion)%>%
  arrange(desc(unidades)) #Ordenamos las unidades de mayor a menor

#Mostramos el producto que más se compra junto
head(df_unidades, 1)
```

11. ¿Cuáles son las combinaciones de productos más frecuentes (dos productos que se compren juntos)?

```{r}

#Identificar bloques de productos dentro de cada archivo

df_frecuencia <- df_lineas %>% filter(str_detect(texto, "^\\d+\\s")) %>% separate(texto, into = c("unidades", "descripcion" ,"p.unidad", "importe"), sep = " {2,}") %>% #Separamos en unidades, descripción, precio de unidad y importe
  filter(descripcion != "DONACIÓN") %>% #Filtramos para que las donaciones no cuenten
  select(archivo, descripcion) %>% group_by(archivo) %>% filter(n() > 1) #Filtramos para que los archivos con un producto no cuenten
  

#Crear pares de productos por ticket
pares_productos <- df_frecuencia %>%
  group_by(archivo) %>%
  summarise(pares = list(combn(descripcion, 2, simplify = FALSE)), .groups = "drop") %>%
  unnest(pares) %>%
  mutate(pares = map(pares, sort)) %>%
  transmute(prod1 = map_chr(pares, 1),
            prod2 = map_chr(pares, 2))

pares_productos <- pares_productos %>% unite(col = "productos", sep = " ") #Se juntan para que al contar cuente las combinaciones de los dos productos

pares_frecuentes <- pares_productos %>% count(productos, sort = T)
```

12. ¿Hay estacionalidad en plátanos? (se compran más en cierta fecha del año)

```{r figura-platano, fig.cap="Cantidad de plátanos comprados por mes"}
#Ya tenemos un df con las fechas, ahora creamos otro con todos los tickets que tienen plátanos.
platanos <- df_lineas %>% filter(str_detect(tolower(texto), "platano"))

#Vamos a ver cuantos kilos se compran de platanos en cada fecha, así que vamos a guardar en un vector las líneas de los archivos que contienen plátanos.
archivo_platanos <- platanos %>% select(archivo) #filtramos los nombres
archivo_platanos <- as.vector(archivo_platanos$archivo) #Convertir a vector

#Con el vector de los archivos creamos un df de las fechas en las que se comparon plátanos
df_fechas_platanos <- df_lineas %>% filter(linea == "5") %>% right_join(data.frame(archivo = archivo_platanos), by = "archivo")

#Filtramos para quedarnos solo con las fechas en formato texto
df_fechas_platanos <- df_fechas_platanos %>%  mutate(fecha = str_extract(texto, "\\b\\d{2}/\\d{2}/\\d{4}\\b")) %>% select(-texto)

#Guardamos la fecha en el df de platanos
platanos$fecha <- df_fechas_platanos$fecha
platanos$fecha <- as.Date(platanos$fecha, format = "%d/%m/%Y") #Convertimos en formato fecha

#Filtramos para hallar los kilos de plátanos en cada compra
vector_platanos <- which(str_detect(tolower(df_lineas$texto), "platano")) #Crea un vector con las filas en las que aparecen los plátanos

#Encontramos la linea donde aparece la cantidad de plátanos (en kg) comprada
filas_kilos_platanos <- vector_platanos + 1

#Añadimos las líneas de los kilos al df
platanos$info <- df_lineas %>% slice(filas_kilos_platanos)%>%pull(texto)

#Arreglamos el df para quedarnos con lo que necesitamos
platanos_limpio <- platanos %>% extract(texto, into = c("unidades", "producto"), 
                                        regex = "^[ ]*([0-9]+)[ ]+([A-Z]+)$") %>% #Opcional que empiecen con espacio, seleccionamos uno o más números del 0 al 9 que haya uno o más espacios y que acabe con uno o más caracteres de la A a la Z para seaparar en dos columnas: unidades y producto

  extract(info, into = c("cantidad", "precio(kg)", "precio(total)"), 
          regex = " {1,}([0-9,]+ kg)[ ]+([0-9,]+ €/kg)[ ]+([0-9,]+)$") %>% #Que empiece con uno o más espacios, que contenga uno o más números del 0 al 9 separados por una "," " " kg que haya uno o más espacios contenga contenga uno o más números del 0 al 9 separados por una "," " " €/kg y que acabe con uno o más números del 0 al 9 separados por una "," para separarlo en 3 columnas: cantidad, precio(kg), precio(total)

  select(producto, fecha, cantidad) %>% #Seleccionamos lo que nos interesa
  
  mutate(cantidad = str_replace(cantidad, " kg", "")) %>% #Eliminamos kg
  
  mutate(cantidad = str_replace(cantidad, ",", ".")) %>% #Cambiamos "," por "." para convertirlo después a numérico
  
  mutate(cantidad = as.numeric(cantidad)) #Convertimos a numerico

#Separamos fechas en mes y año para agrupar y obtener las cantidades totales por mes y año
platanos_limpio <- platanos_limpio %>% mutate(fecha = as.character(fecha)) %>% separate(fecha, into = c("anyo", "mes", "dia"), sep = "-") %>% unite(col = "anyo-mes", c(anyo,mes), sep = "-") %>% select(`anyo-mes`, cantidad) %>% group_by(`anyo-mes`) %>% summarize(cantidad_total = sum(cantidad)) %>% arrange(`anyo-mes`)

#Graficamos
grafico_platanos <- platanos_limpio %>% ggplot(aes(x = `anyo-mes`, y = cantidad_total)) + geom_point(aes(color = `anyo-mes`)) + labs(title = "Kg de plátanos comprados por cada mes y año")
grafico_platanos

```

Como se puede comprobar en la gráfica \@ref(fig:figura-platano) se compran más platanos en los meses de enero, 
febrero y marzo, por tanto, los plátanos tienen estacionalidad.

13. ¿Cuántos productos se compran por ticket, en promedio?

14. ¿Cuál es el importe medio por ticket? ¿Cuál es el ticket más caro registrado? ¿Y el más barato?

15. ¿Cuál es la cantidad total de dinero que se obtiene en impuestos cuando se venden alimentos con un 10% de IVA? ¿Y con un 21% y un 5%?

Queremos calcular la cantidad total de dinero recaudado en concepto de impuestos (IVA) a partir de los tickets de compra proporcionados. En este caso, nos piden centrarnos solo en 3 tipos de IVA (21%, 10% y 5%).

Para poder realizar este análisis, primero debemos partir del dataframe original (df_lineas). Como los datos del IVA se pueden encontrar en diferentes lineas utilizaremos una expresión regular que detecte información sobre el IVA. Esto lo haremos mediante la función str_detect() de la librería stringr. Además usaremos una serie de funciones para transformar y organizar los datos.

```{r}
df_IVA<-df_lineas %>% 
  #seleccionamos las filas del dataframe que coincidan con la expresión regular.
  filter(str_detect(texto, "^\\s*\\d{1,2}%?\\s+\\d+[,.]\\d{2}\\s+\\d+[,.]\\d{2}")) %>%
  
  #"^\\s*\\d{1,2}%?\\s+\\d+[,.]\\d{2}\\s+\\d+[,.]\\d{2}" es la expresión regular:
          #"^" Asegura que el patrón comience al principio de línea.

          #"\\s*" Permite que la línea pueda comenzar con espacios.
  
          #"\\d{1,2}" Captura uno o dos dígitos (como 5, 10 o 21).
          
          #"%?" Detecta el número o el número y el porcentaje.

          #"\\s+" Requiere al menos un espacio entre el porcentaje y el siguiente número.

          #"$" Indica el final de la línea.
  mutate(
  #Elimina espacios innecesarios al principio, final y entre palabras
  texto=str_squish(texto),
  
  #Extraemos los componentes porcentaje, base y cuota con la expresión regular.
  porcentaje = str_extract(texto, "^\\d{1,2}"),
  base = str_extract(texto, "(?<=\\s)\\d+[,.]\\d{2}(?=\\s+\\d+[,.]\\d{2}$)"),
  cuota = str_extract(texto, "\\d+[,.]\\d{2}$")
  ) %>% 
  
  #Convertimos los strings en valores numéricos
  mutate(
    #Se elimina el símbolo %
    porcentaje = as.numeric(str_replace(porcentaje, "%", "")),
    #Se reemplaza comas por puntos en decimales
    base = as.numeric(str_replace(base, ",", ".")),
    cuota = as.numeric(str_replace(cuota, ",", "."))
  ) %>%
  #Seleccionamos las columnas que nos interesan
  select(archivo, linea, porcentaje, base, cuota)

```
Ya hemos creado el dataframe que contiene toda la información del IVA proporcionada en los tickets. Ahora a partir de este agruparemos todas las líneas por porcentaje de IVA y sumaremos todas las cuotas asociadas a los tipos de IVA. Una vez lo tengamos utilizaremos la función filter() para así centrarnos únicamente en los tres tipos de IVA que queremos analizar, que son IVA del 5%, 10% y 21%.

```{r figura-TiposIVA}

total_TipoIVA <- df_IVA %>%
  #Agrupamos juntas todas las filas con el mismo porcentaje de IVA.
  group_by(porcentaje) %>%
  summarise(
    #Para cada grupo de porcentaje de IVA, calcula la suma de los valores en la columna cuota
    Cuota= sum(cuota, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  #Ordenamos los resultados de mayor a menos porcentaje de IVA.
  arrange(desc(porcentaje))

#Mostrar solo los tipos que nos interesan, en este caso solo el 21%, 10% y 5%
IVA_filtrado <- total_TipoIVA %>%
  filter(porcentaje %in% c(21, 10, 5))

#Mostramos el resultado mediante una tabla.
kable(IVA_filtrado, caption = "Total de IVA por tipo de porcentaje")

#Podemos representarlo en un gráfico de barras para mostrar la gran diferencia entre el dinero recogido según el tipo de IVA.
ggplot(IVA_filtrado, aes(x = factor(porcentaje), y = Cuota)) +
  geom_bar(stat = "identity", fill = "steelblue") +
  labs(
    title = "Total de IVA recaudado por tipo de porcentaje",
    x = "Porcentaje de IVA",
    y = "Total en €"
  ) +
  theme_minimal()

```
La tabla y el gráfico revelan que la mayor recaudación por IVA, con un total de 666.01€, corresponde a los productos gravados al 10%. En cambio, los productos con un IVA del 21% generaron una recaudación de 256.74€, mientras que aquellos con un IVA del 5% aportaron 8.21€.

Por último, queremos verificar si se han tenido en cuenta todos los tickets y que no se haya perdido ningún dato en el proceso de extracción del IVA. Podemos comparar el número total de tickets únicos en el dataframe original (df_lineas) con el número de tickets para los cuales se pudo extraer distinta información del IVA en el dataframe lineas_IVA.

```{r}
#Aplicamos la función unique() seleccionando en el data frame la columna archivo, esta función obtiene los valores únicos. Además con la función length nos muestra la cantidad de ticket distintos.
total_tickets <- length(unique(df_lineas$archivo))
tickets_con_IVA <- length(unique(df_IVA$archivo))

cat("Tickets totales:", total_tickets, "\n")
cat("Tickets con IVA:", tickets_con_IVA, "\n")
```
Como podemos ver, ambos números son iguales (total de tickets únicos y tickets con el IVA extraido), entonces no hay ningún dato perdido.


16. ¿A qué horas se suele ir más a comprar en los supermercados? ¿Cuáles son las que menos?

Queremos saber qué horas del día tienen mayor y menor afluencia en supermercados. Para ello, necesitamos extraer la hora de compra registrada en cada ticket.

Dado que la hora puede encontrarse en diferentes líneas dentro del ticket, aplicamos una expresión regular que detecta el formato "hh:mm". Esto se realiza mediante la función str_extract() de la librería stringr. Además usamos una serie de funciones para transformar y organizar los datos.

Este proceso nos permite construir un nuevo data frame (df_horas) con la hora de compra de cada ticket.

```{r}
df_horas <- df_lineas %>%
  mutate(
    #buscamos una hora en formato "hh:mm" usando expresiones regulares.
    hora_texto = str_extract(texto, "\\b\\d{1,2}:\\d{2}\\b") 
        
    #"\\b\\d{1,2}:\\d{2}\\b" es la expresión regular:
    
              #"\\b" significa el límite de palabra, se asegura que la coincidencia esté al inicio o al final de una palabra.
                  
              #"\\d{1,2}" Coincide con 1 o 2 dígitos (para horas como 8 o 14)
                  
              #":" Dos puntos, separa la hora y los minutos
              
              #"\\d{2}" Coincide con exactamente 2 dígitos (para minutos como 05 o 41).    
    
              #"\\b" es el límite de palabra (el final)
  )%>% 
  
  #!is.na() crea un vector donde si hay valores en hora_texto es TRUE y donde no haya es FALSE. Utilizando la función filter() filtramos las líneas TRUE, en las que hay       valores. 
  filter(!is.na(hora_texto)) %>%
  #Utilizamos group_by que agrupa todas las líneas que pertenecen al mismo ticket.
  group_by(archivo)%>%
  #Dentro de cada agrupación de ticket (que ahora solo contiene las líneas con hora), selecciona la primera de esas líneas.
  slice_head(n=1)%>%
  mutate(
     #la función hour() extrae solo la hora numérica (selecciona 14 en vez de 14:41).La función hm() convierte la hora como texto a un objeto de tiempo.
     hora = hour(hm(hora_texto))) %>%
     #Seleccionamos la hora y el nombre del archivo.
     select(archivo, hora)
```
A partir del nuevo data frame (df_horas) contamos con que frecuencia de tickets por cada hora del día y lo visualizamos en un gráfico de barras. Así, podemos identificar con claridad las horas pico de afluencia y las horas más tranquilas.

```{r figura-Frecuenciahoras}
#Utilizamos la función count() (aplicandola al data frame df_horas). Esta función cuenta cuántos tickets hay por cada hora del día (de 0 a 23) 
FrecuenciaHora_supermercado<- df_horas %>% count(hora)

#Realizamos una gráfico que muestre qué hora es más frecuente:
#Utilizamos la función ggpplot() y geom_bar() que crean un gráfico de barras.
ggplot(FrecuenciaHora_supermercado, aes(x = hora, y = n)) +
  geom_bar(stat = "identity", fill = "lightgreen") +
  labs(
    title = "Frecuencia de compras por hora del día",
    x = "Hora (24h)",
    y = "Número de tickets"
  ) +
  #Esta función muestra todas las horas del 0 al 23 en el eje X.
  scale_x_continuous(breaks = 0:23) +
  #Esta función aplica un diseño mucho más limpio y simple ya que elimina el fondo gris, pone las líneas de las cuadrículas más ligeras etc.
  theme_minimal()
```
El gráfico de barras muestra que las horas de mayor afluencia en el supermercado son las 20h y las 19h, con poco más de 50 y 40 tickets registrados respectivamente. En cambio, las horas de menor afluencia, sin considerar el horario de cierre (8h y 22h), son las 10h y las 9h, con menos de 5 tickets a las 10h y menos de 10 a las 9h.

Por último, queremos verificar si se han tenido en cuenta todos los tickets y que no se haya perdido ningún dato en el proceso de extracción de la hora. Podemos comparar el número total de tickets únicos en el dataframe original (df_lineas) con el número de tickets para los cuales se pudo extraer una hora en el dataframe df_horas.

```{r}
#Aplicamos la función unique() seleccionando en el data frame la columna archivo, esta función obtiene los valores únicos. Además con la función length nos muestra la cantidad de ticket distintos.
length(unique(df_lineas$archivo))

#Ahora seleccionamos las columnas del nuevo dataframe donde se encuentra solo las horas de cada ticket.
nrow(df_horas)
```
Como podemos ver, ambos números son iguales (total de tickets únicos y tickets con hora extraída), entonces no hay ningún dato perdido.


17. ¿Qué método de pago es más frecuente en los tickets: tarjeta o efectivo? Muéstralo mediante un box plot ¿Cuánto se ha gastado en total con cada método de pago?

Nos piden averiguar cual es el método de pago que más se repite: efectivo o tajeta.

En este caso se repite el hecho de que la forma de pago puede encontrarse en diferentes líneas dentro del ticket, por eso vamos a aplicar la funcion str_detect() para ver si es Tarjeta o Efectivo. Además queremos calcular también el importe total de cada método de pago. 

```{r}
resumen_tickets <- df_lineas %>%
  #Agrupamos todas las líneas que pertenecen al mismo ticket.
  group_by(archivo) %>%  
  #Determinamos el tipo de pago
  summarise(Metodo_Pago = case_when(
    
#Buscamos en todas las líneas de texto del ticket si alguna contiene Tarjeta Bancaria o Efectivo (da igual que este en mayúsculas o minúsculas) y lo asignamos a       Efectivo o a Tarjeta.
  any(str_detect(texto, regex("TARJETA BANCARIA | TARJ. BANCARIA | TARJ BANCARIA", ignore_case = TRUE))) ~ "Tarjeta",
  any(str_detect(texto, regex("EFECTIVO|PAGO.?EFECTIVO|PAGADO EN EFECTIVO", ignore_case = TRUE))) ~ "Efectivo",
  
  #Si no se cumple ninguna condición anterior se asigna "Desconocido" como método de pago.
  TRUE ~ "Desconocido"
),
    # Extraemos el importe total del ticket
    Importe_Total = {
      #Busca la linea de texto que contiene la frase "TOTAL (€)"
      total_linea <- texto[str_detect(texto, "TOTAL \\(€\\)")] 
      #Extrae de esa línea un patrón que representa un número con una coma como separador decimal
      importe <- str_extract(total_linea, "\\d+,\\d{2}")         
      #Si se encuentra un importe, reemplaza la coma por un punto para convertirlo a formato numérico. Si no se encuentra la línea del total o el patrón del importe, asigna       un valor NA.
      if (!is.na(importe)) {
        as.numeric(str_replace(importe, ",", "."))} 
      else {
        #Si no se encuentra, dejamos un valor NA
        NA_real_}}
  ) %>%
  #Eliminamos aquellos tickets donde no se detectó importe total
  filter(!is.na(Importe_Total))  
```
Tenemos ya el dataframe resumen_tickets que contiene solo las líneas de texto que mencionan el método de pago. A partir de este dataframe calcularemos el importe total de cada método de pago. 

```{r}
#Agrupamos por método de pago para ver cuánto se ha gastado con cada uno
totales_por_metodo <- resumen_tickets %>%
  group_by(Metodo_Pago) %>%
  #Sumamos los importes totales por tipo de pago
  summarise(Total_Gastado = sum(Importe_Total)) %>% 
  #Ordenamos de mayor a menor gasto
  arrange(desc(Total_Gastado))  

# Mostramos e el total gastado por método de pago
kable(totales_por_metodo, caption = "Importe total de cada método de pago")
```
Como se puede observar cada ticket ha coincidido en el método de pago, todos han sido pagados con tarjeta. También vemos que el importe total de todos los tickets es 13.649,8€. 

# Conclusión

Hemos presentado:

1.  Tablas:
    -   Tabla \@ref(tab:tabla-procedencia): Datos de procedencia de los tickets
2.  Figuras:
    -   Figura \@ref(fig:figura-bananas_platanos): Evolución de precio por kilo de las bananas y los plátanos
    -   Figura \@ref(fig:figura-semanas): Tickets recogidos cada día de las semana.
    -   Figura \@ref(fig_figura-TiposIVA): Muestra el dinero total recogido según el tipo de IVA.
    -   Figura \@ref(fig:figura-Frecuenciahoras): Horas de mayor y menor afluencia en el supermercado.
    -   Figura \@ref(fig:figura-platano): Cantidad de plátanos comprados por mes.
