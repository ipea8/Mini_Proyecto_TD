---
title: "ProyectoTD2025"
author:
- Andrea Fu Castelló Sala
- Sergio Del Carme Moreno
- María Martínez Marí
- Jorge Navarro Rodríguez
- Iván Pérez Alonso
- Edurne Serigó Troyano
date: "`r Sys.Date()`"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)

# Configurar nombres en español para gráficos
options(OutDec = ",", digits = 2)
```

## Introducción

Mercadona y otros supermecados como Lidl, Dia y Comsum han implantado el ticket electrónico y los usuarios que lo deseen pueden recibirlo como documento pdf en su correo electrónico, en lugar de hacerlo en papel.

Como alumnos del GCD nos plantemos el siguiente objetivo:

Queremos desarrollar un programa que permita analizar los tickets para realizar un seguimiento de la evolución de precios, compras más habituales, productos más consumidos, supermercado habitual, hora de compra, etc.

Dado que el formato no es el mismo nos vamos a centrar en tickets de Mercadona.

Con este proyecto se espera desarrollar una herramienta capaz de leer y analizar automáticamente tickets de compra de Mercadona, extraídos en formato PDF, para obtener información útil sobre los hábitos de consumo.

## Carga de librerías y datos necesarios para el análisis

En cuanto a datos necesarios para la realización del proyecto, destacamos la carga de librerías como: pdftools, knitr, ggplot2, dplyr, tidyverse y stringr para el desarrollo de nuestro código. Gracias a estas librerías, seremos capaces de poder utilizar las funciones que nos permitan almacenar la información contenida en los tickets en nuestro dataframe.

```{r}
## Cargamos las librerias que vamos a usar
library(pdftools)
library(tidyverse)
library(dplyr)
library(stringr)
library(ggplot2)
library(knitr)
```

## Material y métodos

Para este proyecto se ha utilizado un conjunto de tickets de compra proporcionados en formato PDF. Todos los tickets pertenecen, como hemos comentado antes, a supermercados Mercadona.

El análisis de datos se realiza utilizando el lenguaje de programación R.

Como sabemos, la librería `pdftools` y la función `pdf_text` sirven para cargar el contenido del ticket en un vector de texto. Por lo tanto, los tickets serán leídos uno a uno utilizando la función `pdf_text()` de la librería `pdftools`. A partir de ese texto, se ha extraído:

-   Encabezado (previo a productos) FIJO
-   Parte final (después del Total).
-   Si hay aparcamiento o no (línea extra)
-   Productos: Venta por unidades, Venta al peso (FRUTA y VERDURA) y Venta al peso (PESCADO)

## Importación de datos

Este bloque de código realiza la importación y estructuración de los tickets en formato PDF de Mercadona para su posterior análisis. El objetivo es transformar los tickets en un data frame legible y manipulable en R, donde cada fila representa una línea del ticket, junto con el nombre del archivo (ticket) y el número de línea correspondiente.

Primero se define la ruta donde están almacenados los archivos PDF y luego se genera una lista de todos los archivos dentro de esa ruta que contienen la palabra “Mercadona” en su nombre.

A continuación, aplicamos una función de lectura a cada uno de los archivos PDF encontrados. Dentro de esta función, pdf_text() se encarga de leer el contenido del PDF como texto, devolviendo una lista de páginas. Todas las páginas de un ticket se unen en un solo texto, y luego este texto se divide en líneas individuales usando el carácter de salto de línea.

Por cada archivo, se construye un pequeño data frame con tres columnas: archivo, linea y texto.

Luego, todos estos pequeños data frames se combinan en uno solo, formando el objeto df_lineas, que contiene todas las líneas de todos los tickets.

Por último, se muestra una tabla con las primeras 52 líneas de este data frame (el primer ticket del data frame) para visualizar cómo se ve el contenido de los tickets ya estructurado. Esta visualización permite confirmar que la lectura fue correcta y que los datos están listos para su análisis.

Ahora mostramos el código en el que se muestra todo lo que hemos explicado antes.

```{r}

ruta_tickets<- 'data/'
archivos_pdf <- list.files(path = ruta_tickets, pattern = "Mercadona", 
                           full.names = TRUE, recursive = TRUE)

# Leer todos los archivos y construir un data frame
df_lineas <- do.call(rbind, lapply(archivos_pdf, function(archivo) {
  paginas <- pdf_text(archivo)
  texto <- paste(paginas, collapse = "\n")       # Unir todas las páginas
  lineas <- unlist(strsplit(texto, "\n"))        # Separar en líneas
  
  # Crear un data.frame con nombre del archivo, número de línea y texto
  data.frame(
    archivo = basename(archivo),
    linea = seq_along(lineas),
    texto = lineas,
    stringsAsFactors = FALSE
  )
}))

kable(head(df_lineas,52),caption= "Tabla de tickets de mercadona") #Se muestra el df de los tickets del mercadona
```

\newpage

## Preguntas planteadas por el profesor

1.  ¿Cuáles son los 5 productos, de los vendidos por unidades, con más ventas? ¿Cuántas unidades de cada uno se han vendido?

Queremos identificar los cinco productos más vendidos en términos de unidades. Para ello, debemos analizar aquellas líneas de los tickets que corresponden a productos vendidos por cantidad (unidades) y no por peso o medida. Este tipo de productos suele aparecer en las líneas que comienzan por un número, indicando la cantidad vendida.

Comenzamos filtrando del dataframe original (df_lineas) únicamente las líneas que comienzan por un número. Esto lo haremos mediante una expresión regular que identifique líneas que comienzan con uno o más dígitos seguidos de un espacio. Después, extraeremos las partes clave del texto: cantidad, nombre del producto y, si aparece, el precio total.

Una vez extraídos los datos, creamos un nuevo dataframe con dos columnas: nombre del producto y cantidad vendida. A continuación, agrupamos los productos, sumamos las cantidades y seleccionamos los cinco con mayor número de unidades vendidas. Por último, mostramos los resultados.

```{r tabla-productosvendidos}
# Añadimos la línea siguiente a cada línea para poder detectar si un producto está seguido por "kg"
df_lineas <- df_lineas %>%
  arrange(archivo, linea) %>%
  group_by(archivo) %>%
  mutate(texto_siguiente = lead(texto)) %>%
  ungroup()

# Detectar productos por unidad
productos_unidades <- df_lineas %>%
  # Comienzan con un número, no contienen "kg" ni "€/kg" y no están seguidos por peso
  filter(str_detect(texto, "^\\d+\\s") & 
           !str_detect(texto, "kg|€/kg") &
           !str_detect(texto_siguiente, "kg|€/kg")) %>%
  mutate(
    cantidad = as.numeric(str_extract(texto, "^\\d+")),
    producto = str_trim(str_remove(
      str_extract(texto, "^\\d+\\s+.+?\\s+\\d+[,.]\\d{2}"), "^\\d+\\s+")),
    producto = str_remove(producto, "\\s+\\d+[,.]\\d{2}$")
  ) %>%
  filter(!is.na(cantidad), !is.na(producto)) %>%
  group_by(producto) %>%
  summarise(unidades_vendidas = sum(cantidad), .groups = "drop") %>%
  arrange(desc(unidades_vendidas)) %>%
  slice_head(n = 5)

kable(productos_unidades, caption = "Top 5 productos vendidos por unidades")

# Explicamos todas las expresiones regulares:
# ^: inicio de linea
# \\d: aparece un dígito
# \\s: aparece un espacio en blanco
# +: una o más veces
# .+?: cualquier carácter (.) uno o más (+), pero lo menos posible (?) (me dice el nombre del producto)
# [,.]: puede ser coma (,) o punto (.) como separador decimal
# \\d{2}: exactamente dos dígitos (los decimales, como "00")
# $: fin de linea
```

Como podemos observar en la tabla \@ref:tabla-productosvendidos, los cinco productos más vendidos por unidades son: leche desnatada con calcio (24 unidades), queso lonchas cabra (20 unidades), copos de avena (16 unidades) barra campesina(14 unidades), chapata cristal(12 unidades) y garbanzo m.cocido (14 unidades).

\newpage

2.  Si consideramos la categoría de FRUTAS Y VERDURAS. Cuáles son los 5 productos más vendidos? ¿Cuántos kilos se han vendido de cada uno de estos productos?

En este análisis queremos centrarnos exclusivamente en los productos pertenecientes a la categoría de frutas y verduras. Para ello, se parte de una lista de palabras clave que identifican nombres comunes de estos productos. El objetivo es identificar las líneas de los tickets que mencionan alguno de estos productos y extraer la cantidad vendida en kilos.

Primero buscamos en el dataframe df_lineas todas las líneas que contienen alguna de estas palabras clave, ignorando mayúsculas o minúsculas. Luego, recorremos una a una esas líneas e intentamos extraer la cantidad en kilos asociada. Si no encontramos la cantidad en la línea principal, revisamos la línea siguiente por si la información estuviera allí. Este valor se convierte a formato numérico unificando el uso de comas y puntos.

Después, limpiamos y estandarizamos los nombres de los productos, convirtiéndolos a mayúsculas y eliminando posibles espacios o caracteres extraños. A continuación, agrupamos por nombre de producto y sumamos los kilos vendidos para cada uno. Finalmente, mostramos los cinco productos más vendidos en esta categoría.

```{r tabla-frutasverduras}

# Lista de palabras clave de frutas y verduras
productos_frutas_verduras <- c("manzana", "plátano", "naranja", "fresa", "pera", "kiwi", "sandía", "melon", "tomate", "lechuga", "pepino", "pimiento", "berenjena", "calabacín", "ajo", "cebolla", "zanahoria", "patata", "aguacate", "brocoli", "col", "apio", "alcachofa", "espárrago", "frambuesa", "cereza", "mango", "limón", "mandarina")

# Buscar líneas del df_lineas que contengan alguna de estas palabras
frutas_verduras <- grep(paste(productos_frutas_verduras, collapse = "|"), tolower(df_lineas$texto))

# Crear un nuevo data.frame para guardar resultados
resultados <- data.frame(producto = character(), cantidad_kg = numeric(), stringsAsFactors = FALSE)

# Recorremos cada línea que contiene una fruta o verdura
for (i in frutas_verduras) {
  linea_producto <- df_lineas$texto[i]
 #Extraer nombre del producto
  producto <- gsub("\\s*\\d+\\s*(kg|KG).*", "", linea_producto)  # Limpia el nombre del producto

  # Extraer la cantidad de la misma línea
  match_misma_linea <- regmatches(linea_producto, regexpr("\\d+[.,]?\\d*\\s*(kg|KG)"
                                                          , linea_producto, ignore.case = TRUE))
  
  if (length(match_misma_linea) > 0) {
    cantidad <- as.numeric(gsub(",", ".", gsub(" kg", "", tolower(match_misma_linea))))
  } 
  # Si no hay kilos en esa línea, intenta mirar la línea siguiente
  else if (i + 1 <= nrow(df_lineas)) {
    # Revisar la línea siguiente
    linea_siguiente <- df_lineas$texto[i + 1]
    match_siguiente_linea <- regmatches(linea_siguiente, regexpr("\\d+[.,]?\\d*\\s*(kg|KG)" 
                                                                 , linea_siguiente, ignore.case = TRUE))
    
    if (length(match_siguiente_linea) > 0) {
      cantidad <- as.numeric(gsub(",", ".", gsub(" kg", "", tolower(match_siguiente_linea))))
    } else {
      cantidad <- NA
    }
  } else {
    cantidad <- NA
  }
  
  # Añadir los datos a la tabla
  resultados <- rbind(resultados, data.frame(producto = producto, cantidad_kg = cantidad, stringsAsFactors = FALSE))
}

# Limpieza robusta del nombre del producto
resultados$producto <- toupper(resultados$producto)                     # Todo a mayúsculas
resultados$producto <- gsub("^[^A-Z]*", "", resultados$producto)        # Elimina cualquier cosa que no sea letra al inicio
resultados$producto <- gsub("\\s+", " ", resultados$producto)           # Reemplaza múltiples espacios por uno solo
resultados$producto <- trimws(resultados$producto)                      # Quita espacios delante y detrás


# Agrupar y resumir por producto ya normalizado
top_5_frutas_verduras <- resultados %>%
  filter(!is.na(cantidad_kg)) %>%
  group_by(producto) %>%
  summarise(kilos_totales = sum(cantidad_kg)) %>%
  arrange(desc(kilos_totales))

# Ver los 5 más vendidos
knitr::kable(head(top_5_frutas_verduras),
             caption = "5 frutas y verduras más vendidas (kg)",
             booktabs = TRUE)

# Explicamos todas las expresiones regulares:
# *: cero o más veces
# .*: cualquier cosa después
# ^: inicio de linea
# \\d: aparece un dígito
# \\s: aparece un espacio en blanco
# +: una o más veces
# .+?: cualquier carácter (.) uno o más (+), pero lo menos posible (?) (me dice el nombre del producto)
# [,.]: puede ser coma (,) o punto (.) como separador decimal
# \\d{2}: exactamente dos dígitos (los decimales, como "00")
# $: fin de linea
# [^A-Z]: cualquier caracter que no sea una letra mayuscula de la A a la Z
```

Como podemos observar en la tabla \@ref:tabla-frutasverduras, los cinco productos más vendidos dentro de la categoría de frutas y verduras son: naranja con 82.062Kg, patata con 74.800Kg, mandarina con 31.186Kg, cebolla con 22.000Kg y pepino con 19.624Kg.

\newpage

3.  Si consideramos la categoría de PESCADO. Cuáles son los 5 productos más vendidos? ¿Cuántos kilos se han vendido de cada uno de estos productos?

En este caso nos centramos exclusivamente en los productos pertenecientes a la categoría de pescado y marisco. Para identificar estos productos, definimos una lista de palabras clave. Estas palabras nos permiten buscar en el dataframe df_lineas aquellas líneas de texto que contienen referencias a este tipo de productos.

A continuación, para cada línea detectada, extraemos el nombre del producto y buscamos la cantidad de kilos que se ha vendido, tanto en la línea actual como, si es necesario, en la línea siguiente. El peso se convierte en formato numérico estandarizado. Posteriormente, se limpia y normaliza el texto del nombre del producto (todo en mayúsculas, sin espacios sobrantes ni caracteres innecesarios).

Por último, agrupamos los datos por nombre de producto y sumamos los kilos vendidos para cada uno. Se ordenan de mayor a menor y se extraen los cinco productos más vendidos en kilos.

```{r tabla-pescado}

# Lista de productos de la categoría pescado
productos_pescado <- c("merluza", "salmón", "bacalao", "atún", "lubina", "dorada", "boquerón", "anchoa", "gamba", "calamar", "sepia", "pulpo", "lenguado", "rape", "pez espada", "rodaballo", "jurel", "caballa", "sardina", "mejillón", "bacaladilla")

# Buscar líneas que contengan alguno de esos productos
pescado <- grep(paste(productos_pescado, collapse = "|"), tolower(df_lineas$texto))

# Inicializar el data.frame vacío
resultados_pescado <- data.frame(producto = character(), cantidad_kg = numeric(), stringsAsFactors = FALSE)

# Bucle para recorrer cada línea con pescado
for (i in pescado) {
  linea_producto <- df_lineas$texto[i]
  # Extraer solo el nombre del producto
  producto <- gsub("\\s*\\d+\\s*(kg|KG).*", "", linea_producto)
  
  # Buscar la cantidad de kilos en la misma línea
  match_misma_linea <- regmatches(linea_producto, regexpr("\\d+[.,]?\\d*\\s*(kg|KG)", linea_producto, ignore.case = TRUE))
  
  if (length(match_misma_linea) > 0) {
    # Busca un número decimal seguido de la palabra "kg" y lo convierte en número decimal con gsub()
    cantidad <- as.numeric(gsub(",", ".", gsub(" kg", "", tolower(match_misma_linea))))
  } 
  # Si no encuentra el peso en la línea actual, mira en la siguiente
  else if (i + 1 <= nrow(df_lineas)) {
    # Revisar la línea siguiente
    linea_siguiente <- df_lineas$texto[i + 1]
    match_siguiente_linea <- regmatches(linea_siguiente, regexpr("\\d+[.,]?\\d*\\s*(kg|KG)"
                                                                 , linea_siguiente, ignore.case = TRUE))
    
    if (length(match_siguiente_linea) > 0) {
      cantidad <- as.numeric(gsub(",", ".", gsub(" kg", "", tolower(match_siguiente_linea))))
    } else {
      cantidad <- NA
    }
  } else {
    cantidad <- NA
  }
  
  # Guardar en el data.frame
  resultados_pescado <- rbind(resultados_pescado, data.frame(producto = producto, cantidad_kg = cantidad, stringsAsFactors = FALSE))
}

# Normalización del texto del producto
resultados_pescado$producto <- toupper(resultados_pescado$producto)
resultados_pescado$producto <- gsub("^[^A-Z]*", "", resultados_pescado$producto)
resultados_pescado$producto <- gsub("\\s+", " ", resultados_pescado$producto)
resultados_pescado$producto <- trimws(resultados_pescado$producto)

# Agrupar y sumar los kilos
top_5_pescado <- resultados_pescado %>%
  filter(!is.na(cantidad_kg)) %>%
  group_by(producto) %>%
  summarise(kilos_totales = sum(cantidad_kg)) %>%
  arrange(desc(kilos_totales))

# Mostrar los 5 productos de pescado más vendidos
knitr::kable(head(top_5_pescado),
             caption = "5 pescados más vendidos (kg)",
             booktabs = TRUE)

# Explicamos todas las expresiones regulares:
# *: cero o más veces
# .*: cualquier cosa después
# ^: inicio de linea
# \\d: aparece un dígito
# \\s: aparece un espacio en blanco
# +: una o más veces
# .+?: cualquier carácter (.) uno o más (+), pero lo menos posible (?) (me dice el nombre del producto)
# [,.]: puede ser coma (,) o punto (.) como separador decimal
# \\d{2}: exactamente dos dígitos (los decimales, como "00")
# $: fin de linea
# [^A-Z]: cualquier caracter que no sea una letra mayuscula de la A a la Z
```

Como podemos observar en la tabla \@ref:tabla-pescado, los cinco productos de la categoría pescado más vendidos por kilos son:bacaladilla con 7,4Kg, rodaballo con 3.672Kg, sepia lonja con 3.584Kg, dorada con 2.934Kg y sepia fresca con 2.642Kg.

\newpage

4.  Muestra mediante un gráfico de líneas como ha variado el precio por kilo de las bananas y los plátanos en los tickets disponibles, a lo largo del tiempo.

Para analizar la evolución temporal del precio por kilo de plátanos y bananas, se realiza un filtrado de todas las líneas del dataframe df_lineas que contengan alguna de esas dos frutas. Una vez identificadas estas líneas, se extrae el nombre del archivo (ticket) correspondiente para localizar la fecha de cada transacción.

Las fechas de los tickets se extraen buscando la línea número 5 (que contiene la fecha en cada ticket) y emparejándola con los tickets que contienen banana o plátano. Esta fecha se convierte a formato de fecha para poder utilizarla en un gráfico temporal.

Luego, se obtiene el precio por kilo. Para ello, se asume que el precio aparece en la línea siguiente a donde aparece el nombre del producto, por lo que se extrae el texto de esa línea y se filtra con una expresión regular que busca el formato típico de precio: dos decimales y la etiqueta “€/kg”. Posteriormente, se limpia y transforma este texto a un valor numérico decimal para poder graficarlo.

Finalmente, se normaliza el nombre del producto para identificar si se trata de BANANA o PLÁTANO, y se genera un gráfico de líneas que representa cómo ha variado el precio por kilo de cada fruta a lo largo del tiempo.

```{r figura-bananas_platanos}

#Filtrar las lineas que contengan platano y banana
frutas <- df_lineas %>% filter(str_detect(tolower(texto), "platano|banana"))

#Creamos un vector con los nombres de los tickets que han combrado banana o platano
archivo_frutas <- frutas %>% select(archivo) #filtramos los nombres
archivo_frutas <- as.vector(archivo_frutas$archivo) #Convertir a vector

#Creamos un df que contiene las fechas de los tickets que han comprado platano o banana
df_fechas <- df_lineas %>% filter(linea == "5") %>% right_join(data.frame(archivo = archivo_frutas), by = "archivo") #filtramos las fechas
df_fechas <- df_fechas %>%  mutate(fecha = str_extract(texto, "\\b\\d{2}/\\d{2}/\\d{4}\\b")) %>% select(-texto) #Guardamos solo la fecha
frutas$fecha <- df_fechas$fecha #Guardamos en el vector de frutas
frutas$fecha <- as.Date(frutas$fecha, format = "%d/%m/%Y") #Convertimos en fecha

#Obtener el precio por kilo de platano y banana
filas_frutas <- which(str_detect(tolower(df_lineas$texto), "platano|banana")) #Buscamos la linea de platano o banana
filas_precio_kilo <- filas_frutas + 1 #Obtenemos la linea del precio por kilo
frutas$precio <- df_lineas %>% slice(filas_precio_kilo)%>%pull(texto) #Se agrega al df de frutas
frutas <- frutas %>%  mutate(precio_kg = str_extract(precio, "\\b\\d+,\\d{2}\\s€/kg\\b")) %>% select(-precio) #Se guarda solo el precio por kilo
frutas <- frutas %>%
  mutate(precio_kg = str_replace(precio_kg, " €/kg", "") %>%  # Elimina " €/kg"
         str_replace(",", ".") %>%     # Cambia coma por punto decimal
         as.numeric())

#Arreglar el df
frutas <- frutas %>% select(-archivo) %>% select(-linea) #Eliminar columnas sobrantes
frutas <- frutas %>%  mutate(tipo = str_extract(texto, "BANANA|PLATANO"))%>% select(-texto)

# Gráfico de líneas
ggplot(frutas, aes(x = fecha, y = precio_kg, color = tipo)) +
  geom_line() +
  geom_point() +
  labs(title = "Evolución de Precios por Kg",
       x = "Fecha",
       y = "Precio por Kg",
       color = "Tipo de Fruta")

# Explicamos todas las expresiones regulares:
# \\b: marca el comienzo o el final de una palabra
# \\d: aparece un dígito
# \\s: aparece un espacio en blanco
# +: una o más veces
# \\d{2}: exactamente dos dígitos (los decimales, como "00")
# \\d{4}: exactamente cuatro dígitos

```

El gráfico \@ref:figura-bananas_platanos permite visualizar de manera clara cómo ha cambiado el precio por kilo de plátanos y bananas en las distintas fechas en las que fueron comprados. Se observan posibles fluctuaciones de precio a lo largo del tiempo, lo que puede ser útil para analizar tendencias de mercado o patrones de compra.

\newpage

5.  ¿Cuál es la procedencia de los tickets? ¿Qué ciudad/ pueblo tiene un mayor número de tickets?

Para responder a esta pregunta, se analiza la línea número 3 de cada ticket, ya que en ese campo se encuentra la información de la procedencia, es decir, la ciudad o pueblo en el que se emitió el ticket.

Primero, se extrae todo el contenido de la línea 3 del dataframe df_lineas, que contiene el texto correspondiente a la dirección o localidad. Luego, se limpia ese texto eliminando espacios en blanco al principio y al final, así como cualquier número, con el objetivo de quedarse únicamente con el nombre del municipio o localidad.

Una vez obtenidos los nombres limpios de las ciudades o pueblos, se crea una tabla de frecuencias que cuenta cuántas veces aparece cada uno. Esta tabla muestra el número de tickets por localidad, lo que permite saber qué ciudad o pueblo es el que ha generado más tickets en el conjunto de datos.

Finalmente, se ordena la tabla de manera descendente, de modo que la ciudad con mayor número de tickets aparece en la parte superior de la tabla, y se muestra en un formato presentable.

```{r tabla-procedencia}
#Creamos un nuevo vector con los lugares de procedencia de los tickets
procedencia <- df_lineas %>% filter(linea == "3") %>% pull(texto) #Filtrar por el lugar
procedencia <- gsub("^\\s+|\\s+$|[0-9]", "", procedencia) #Guardar solo la ciudad/pueblo

procedencia <- as.data.frame(table(procedencia)) #Crear un df a partir de la frecuencia de cada ciudad/pueblo
procedencia <- procedencia[order(-procedencia$Freq), ] #Ordenamos de mayor a menor la frecuencia

knitr::kable(procedencia, 
             caption = "Procedencia de los tickets", 
             booktabs = TRUE)

# Explicamos todas las expresiones regulares:
# ^: inicio de linea
# |: es el operador "o" en las expresiones regulares
# \\s: aparece un espacio en blanco
# +: una o más veces
# [0-9]: cualquier dígito entre 0 y 9
# $: fin de la linea
```

En la tabla \@ref:tabla-procedencia podemos ver el resultado de la procedencia de los tickets, siendo valencia la ciudad más frecuente con 130 tickets, seguido de alboraia con 50 tickets y después burjassot con 26 tickets.

\newpage

6.  Muestra mediante un diagrama el número de tickets recogidos cada día de las semana. ¿Si tuvieses que cerrar un día entre semana qué día lo harías?

Para responder a esta pregunta, se analizan las fechas de los tickets con el objetivo de identificar en qué día de la semana se ha generado cada uno, y así contar cuántos tickets corresponden a cada día.

Primero, se filtran las líneas correspondientes a la fecha del ticket, que se encuentran en la línea 5 del dataframe df_lineas. Luego, se extrae la fecha en formato dd/mm/yyyy y se convierte en un objeto Date, lo cual permite identificar automáticamente a qué día de la semana pertenece cada fecha.

A continuación, se genera un recuento de tickets por día de la semana, lo que nos da la frecuencia de tickets para cada día. Este recuento se convierte en un data.frame y se ordenan los días de la semana manualmente para asegurar que el gráfico muestre los días en el orden lógico (de lunes a domingo).

Finalmente, se construye un gráfico de barras que muestra claramente cuántos tickets se han generado en cada día. Esto permite visualizar qué días son más activos y cuáles menos, ayudando a responder la pregunta de negocio: ¿Qué día sería el más adecuado para cerrar?

El día con menos tickets generados sería, en principio, el más adecuado para cerrar, ya que implicaría un menor impacto económico.

```{r figura-semanas}
df_fechas <- df_lineas %>% filter(linea == "5") #filtrar fechas
df_fechas <- df_fechas %>%  mutate(fecha = str_extract(texto, "\\b\\d{2}/\\d{2}/\\d{4}\\b")) %>% select(-texto) #Guardamos solo la fecha
df_fechas$fecha <- as.Date(df_fechas$fecha, format = "%d/%m/%Y") #Convertir str a fecha

df_fechas$dia_semana <- weekdays(df_fechas$fecha) #Crear una nueva columna con los dias de la semana de cada fecha
dia_semana <- as.vector(df_fechas$dia_semana) #Convertir a vector solo de los dias de la semana

dia_semana <- as.data.frame(table(dia_semana)) #Convertir a df a partir de la frecuencia de cada dia de la semana
names(dia_semana)[names(dia_semana) == "dia_semana"] <- "semana"

orden_dias <- c("lunes", "martes", "miércoles", "jueves", "viernes", "sábado", "domingo")
dia_semana$semana <- factor(dia_semana$semana, levels = orden_dias)

#Diagrama
ggplot(dia_semana, aes(x = semana, y = Freq, fill = semana)) +
  geom_bar(stat = "identity") +  # "identity" usa los valores de 'Freq'
  labs(title = "Tickets recogidos cada día de las semana",
    x = "Día de la semana",
    y = "Número de tickets")

# Explicamos todas las expresiones regulares:
# \\b: marca el comienzo o el final de una palabra
# \\d{2}: exactamente dos dígitos (los decimales, como "00")
# \\d{4}: exactamente cuatro dígitos
```

Como se observa en la figura \@ref:figura-semanas, si se tuviese que cerrar un día entre semana seria el jueves.

\newpage

## Preguntas planteadas por nosotros

7.  ¿Cuál es la media de ventas para cada día de la semana?

Se calcula la media de productos vendidos por ticket según el día de la semana. Para ello, se extrae la fecha desde el nombre del archivo y se identifican las líneas que representan productos reales. Luego, se cuenta cuántos productos hay por ticket y se asocia cada uno a su día de la semana. Finalmente, se calcula la media de productos por día, ordenando los días de lunes a domingo.

```{r tabla-medias}
library(dplyr)
library(stringr)
library(lubridate)

# 1. Extraer la fecha desde el nombre del archivo (formato YYYYMMDD)
df_fechas <- df_lineas %>%
  mutate(
    fecha = str_extract(archivo, "\\d{8}"),
    fecha = as.Date(fecha, format = "%Y%m%d")
  ) %>%
  distinct(archivo, .keep_all = TRUE) %>%
  select(archivo, fecha)

# 2. Contar líneas que representan productos reales (entre línea 12 y "TOTAL"/"PARKING" y que empiecen por entero)
df_productos <- df_lineas %>%
  group_by(archivo) %>%
  mutate(
    # Detectar la primera línea con "TOTAL" o "PARKING"
    linea_fin = min(
      c(
        linea[str_detect(texto, regex("TOTAL", ignore_case = TRUE))],
        linea[str_detect(texto, regex("PARKING", ignore_case = TRUE))]
      ),
      na.rm = TRUE
    ),
    linea_fin = ifelse(is.infinite(linea_fin), max(linea), linea_fin),

    # Marcar si es línea de producto real
    es_producto = linea >= 12 &
                  linea < linea_fin &
                  str_detect(str_trim(texto), "^\\d+\\s")
  ) %>%
  summarise(num_productos = sum(es_producto), .groups = "drop")

# 3. Unir con fechas y agregar día de la semana
df_final <- df_productos %>%
  left_join(df_fechas, by = "archivo") %>%
  mutate(dia_semana = str_to_lower(weekdays(fecha)))

# 4. Calcular media de productos por día de la semana
media_por_dia <- df_final %>%
  group_by(dia_semana) %>%
  summarise(media_productos = mean(num_productos), .groups = "drop") %>%
  arrange(factor(dia_semana, levels = c("lunes", "martes", "miércoles", "jueves", "viernes", "sábado", "domingo")))

# 5. Mostrar resultado
print(media_por_dia)

# Explicamos todas las expresiones regulares:
# \\d: aparece un dígito
# \\s: aparece un espacio en blanco
# +: una o más veces
# \\d{8}: exactamente ocho dígitos

```

Finalmente, en la tabla \@ref:tabla-medias podemos ver el resultado: la media de productos los lunes es de 17, la de los martes es de 14, la de los miércoles es de 16, la de los jueves es de 11, la de los viernes es de 16, la de los sábados es de 19 y la de los domingos es de 30. Podemos observar que, de normal, el dia que menos productos se venden es el jueves.

\newpage

8.  ¿Cómo ha evolucionado el precio por unidad o por kilo de un producto específico a lo largo del tiempo? Hacer el gráfico de cómo varía el precio de un producto a lo largo del tiempo.

Se analiza cómo ha evolucionado el precio por kilo de cada producto con unidad €/kg a lo largo del tiempo. Para ello, se extrae el precio de cada línea del ticket y se asocia al nombre del producto de la línea anterior. Luego, se limpia y agrupa esta información por producto. Finalmente, se genera un gráfico por producto mostrando su precio en función del tiempo.

```{r figura-evolucion_precio_manzanas, fig.cap="Evolución del precio por kg de manzana"}

library(dplyr)
library(stringr)
library(lubridate)
library(ggplot2)

# 1. Asegurar tipos y limpiar símbolos raros
df_lineas <- df_lineas %>%
  mutate(
    linea = as.integer(linea),
    texto = str_replace_all(texto, "Ôé¼", "€"),
    fecha = as.Date(str_extract(archivo, "\\d{8}"), format = "%Y%m%d")
  )

# 2. Filtrar solo las líneas que contienen '€/kg' y extraer precio
df_pesados <- df_lineas %>%
  filter(str_detect(texto, "€/kg")) %>%
  mutate(
    precio_kg = as.numeric(
      str_replace(
        str_extract(texto, "\\d+[.,]\\d{2}(?=\\s*€/kg)"),
        ",", "."
      )
    )
  ) %>%
  select(archivo, fecha, linea, texto, precio_kg)

# 3. Añadir columna 'producto' desde línea anterior y normalizar
df_pesados <- df_pesados %>%
  mutate(linea_anterior = linea - 1) %>%
  left_join(
    df_lineas %>%
      select(archivo, linea, texto) %>%
      rename(texto_producto = texto),
    by = c("archivo", "linea_anterior" = "linea")
  ) %>%
  mutate(
    producto = texto_producto %>%
      str_replace("^\\d+\\s+", "") %>%
      str_replace_all("[^A-Za-zÁÉÍÓÚÜÑáéíóúüñ\\s]", "") %>%
      str_squish() %>%
      str_to_upper()
  ) %>%
  select(archivo, fecha, linea, texto, precio_kg, producto)

# 4. Obtener productos únicos
productos_unicos <- df_pesados %>%
  filter(!is.na(producto), producto != "") %>%
  distinct(producto) %>%
  pull(producto)

# 5. Crear lista de data.frames por producto
df_por_producto <- lapply(productos_unicos, function(nombre) {
  df_pesados %>%
    filter(producto == nombre) %>%
    arrange(fecha)
})
names(df_por_producto) <- productos_unicos

# 6. Mostrar todos los gráficos en pantalla, evitando warnings si hay solo una observación
for (nombre in productos_unicos) {
  df_producto <- df_por_producto[[nombre]]
  
  p <- ggplot(df_producto, aes(x = fecha, y = precio_kg)) +
    {
      if (nrow(df_producto) > 1) geom_line(color = "steelblue", linewidth = 1) else NULL
    } +
    geom_point(color = "darkred", size = 2) +
    labs(
      title = paste("Evolución del precio por kilo:", nombre),
      x = "Fecha",
      y = "€/kg"
    ) +
    theme_minimal()
  
  print(p)
}

# Explicamos todas las expresiones regulares:
# *:cero o más veces
# ^: inicio de linea
# \\d: aparece un dígito
# \\s: aparece un espacio en blanco
# +: una o más veces
# (?=\\s*€/kg): Asegura que lo que sigue después del número sean cero o más espacios y el texto literal "€/kg", pero no lo incluye en el resultado
# [,.]: puede ser coma (,) o punto (.) como separador decimal
# \\d{2}: exactamente dos dígitos (los decimales, como "00")
# \\d{8}: exactamente ocho dígitos
# [^A-Za-zÁÉÍÓÚÜÑáéíóúüñ\\s]: busca todo lo que NO sea una letra del alfabeto inglés o español (tanto mayúscula como minúscula), ni un espacio en blanco

```

Como podemos ver en el gráfico \@ref:figura-evolucion_precio_manzanas, el precio por kilo tiene picos de subida en la primera mitad del año 2024 y luego baja mucho y se mantiene constante.

\newpage

9.  ¿Cuáles son los productos menos vendidos en el conjunto de tickets disponibles?

Se analizan los tickets para identificar los productos no vendidos al peso, filtrando aquellos que no contienen "€/kg" y comienzan por una cantidad. Luego, se limpian y estandarizan los nombres de los productos para evitar duplicados. A continuación, se cuentan las apariciones de cada producto. Finalmente, se muestran los 10 más vendidos y los 10 menos vendidos.

```{r tabla-menosvendidos}
# 1. Identificar productos no pesados (sin €/kg y que comienzan por un número)
df_no_peso <- df_lineas %>%
  mutate(
    linea = as.integer(linea),
    texto = str_replace_all(texto, "Ôé¼", "€"),
    fecha = as.Date(str_extract(archivo, "\\d{8}"), format = "%Y%m%d")
  ) %>%
  group_by(archivo) %>%
  mutate(
    linea_total = min(linea[str_detect(texto, regex("TOTAL", ignore_case = TRUE))], na.rm = TRUE),
    es_producto = linea >= 12 &
                  linea < ifelse(is.infinite(linea_total), max(linea), linea_total) &
                  str_detect(texto, "^\\d+\\s") &
                  !str_detect(texto, "€/kg")
  ) %>%
  ungroup() %>%
  filter(es_producto)

# 2. Extraer y limpiar el nombre del producto
df_no_peso <- df_no_peso %>%
  mutate(
    producto = texto %>%
      str_replace("^\\d+\\s+", "") %>%                             # eliminar cantidad
      str_replace_all("[^A-Za-zÁÉÍÓÚÜÑáéíóúüñ\\s]", "") %>%         # limpiar símbolos
      str_squish() %>%
      str_to_upper()
  )

# 3. Contar productos y mostrar los menos vendidos
productos_no_peso_menos_vendidos <- df_no_peso %>%
  count(producto, sort = TRUE) %>%
  filter(!is.na(producto), producto != "") %>%
  arrange(n)  # ordenar de menor a mayor

# 4. Mostrar los 10 menos vendidos
head(productos_no_peso_menos_vendidos, 10)


#los productos mas vendidos que no van por peso
# Ordenar de mayor a menor frecuencia
productos_no_peso_mas_vendidos <- df_no_peso %>%
  count(producto, sort = TRUE) %>%
  filter(!is.na(producto), producto != "") %>%
  arrange(desc(n))  # mayor a menor

# Mostrar los 10 más vendidos
head(productos_no_peso_mas_vendidos, 10)

# Explicamos todas las expresiones regulares:
# *:cero o más veces
# ^: inicio de linea
# \\d: aparece un dígito
# \\s: aparece un espacio en blanco
# +: una o más veces
# (?=\\s*€/kg): Asegura que lo que sigue después del número sean cero o más espacios y el texto literal "€/kg", pero no lo incluye en el resultado
# [,.]: puede ser coma (,) o punto (.) como separador decimal
# \\d{2}: exactamente dos dígitos (los decimales, como "00")
# \\d{8}: exactamente ocho dígitos
# [^A-Za-zÁÉÍÓÚÜÑáéíóúüñ\\s]: busca todo lo que NO sea una letra del alfabeto inglés o español (tanto mayúscula como minúscula), ni un espacio en blanco
```

\newpage

10. En una compra, ¿cuál es el producto por unidad que se adquiere en mayor cantidad? (NO FRUTAS Y VERDURAS NI PESCADO)

Buscamos identificar cuál es el producto que más se compra por unidades en los tickets disponibles. Para ello, primero se filtran aquellas líneas del conjunto de datos (df_lineas) que comienzan con un número seguido de un espacio.

Una vez filtradas esas líneas, el código divide cada una de ellas en varias columnas separadas: unidades, descripción del producto, precio por unidad e importe total. Después se realiza una limpieza adicional para eliminar productos que no corresponden a una venta real, que a veces aparecen registradas pero no deben considerarse en el análisis.

Luego, se seleccionan únicamente las columnas de unidades y descripción del producto, ya que el análisis se centra en saber qué producto se ha comprado en la mayor cantidad de unidades. Estos datos se ordenan de mayor a menor en función del número de unidades, con el fin de destacar los productos que se compran en grandes cantidades. Finalmente, se muestra el primer resultado de esta lista ordenada, que corresponde al producto más comprado por unidades en una sola transacción.

```{r tabla-masunidades}
#Filtramos solo las líneas que contengan productos por unidades

#Como queremos hacer algo parecido a lo que hemos hecho en la primera pregunta podemos utilizar parte de ese código otra vez

df_unidades <- df_lineas %>% filter(str_detect(texto, "^\\d+\\s")) %>% separate(texto, into = c("unidades", "descripcion" ,"p.unidad", "importe"), sep = " {2,}") %>% #Separamos en unidades, descripción
  filter(descripcion != "DONACIÓN") %>% #Filtramos para que las donaciones no cuenten
  select(unidades, descripcion)%>%
  arrange(desc(unidades)) #Ordenamos las unidades de mayor a menor

#Mostramos el producto que más se compra junto
knitr::kable(head(df_unidades, 1),
             caption = "Producto con el mayor número de unidades en un ticket",
             booktabs = TRUE)

# Explicamos todas las expresiones regulares:
# ^: inicio de linea
# \\d: aparece un dígito
# \\s: aparece un espacio en blanco
# +: una o más veces

```

Como podemos observar en la tabla \@ref:tabla-masunidades, el producto más comprado por unidades en una sola transacción es la cola sin cafeina (8 unidades).

\newpage

11. ¿Cuáles son las combinaciones de productos más frecuentes (dos productos que se compren juntos)?

El objetivo de esta pregunta es identificar qué pares de productos suelen comprarse juntos en un mismo ticket. Para comenzar, se filtran las líneas del dataset que contienen información sobre productos vendidos por unidad. Estas líneas se dividen en varias columnas como unidades, descripción del producto, precio por unidad e importe total. Se excluyen las líneas que hacen referencia a "DONACIÓN" para evitar sesgos en los datos. Luego, se seleccionan solo las columnas relevantes, en este caso el archivo (que identifica el ticket) y la descripción del producto. Posteriormente, se agrupan los datos por ticket y se eliminan aquellos que solo contienen un producto, ya que no pueden formar combinaciones.

Una vez obtenidos los tickets con al menos dos productos, se generan todas las combinaciones posibles de dos productos dentro de cada ticket. Cada par se ordena alfabéticamente para evitar que el orden afecte el conteo. Luego, los pares se combinan en una sola cadena de texto para facilitar su conteo. Finalmente, calculamos cuántas veces aparece cada combinación en todos los tickets, ordenando los resultados de mayor a menor frecuencia.

```{r tabla-combinaciones}

#Identificar bloques de productos dentro de cada archivo

df_frecuencia <- df_lineas %>% filter(str_detect(texto, "^\\d+\\s")) %>% separate(texto, into = c("unidades", "descripcion" ,"p.unidad", "importe"), sep = " {2,}") %>% #Separamos en unidades, descripción, precio de unidad y importe
  filter(descripcion != "DONACIÓN") %>% #Filtramos para que las donaciones no cuenten
  select(archivo, descripcion) %>% group_by(archivo) %>% filter(n() > 1) #Filtramos para que los archivos con un producto no cuenten
  

#Crear pares de productos por ticket
pares_productos <- df_frecuencia %>%
  group_by(archivo) %>%
  summarise(pares = list(combn(descripcion, 2, simplify = FALSE)), .groups = "drop") %>%
  unnest(pares) %>%
  mutate(pares = map(pares, sort)) %>%
  transmute(prod1 = map_chr(pares, 1),
            prod2 = map_chr(pares, 2))

pares_productos <- pares_productos %>% unite(col = "productos", sep = " ") #Se juntan para que al contar cuente las combinaciones de los dos productos

pares_frecuentes <- pares_productos %>% count(productos, sort = T)

#Mostramos los 5 primeros
knitr::kable(head(pares_frecuentes),
             caption = "Pares de productos diferentes que se compran más veces juntos",
             booktabs = TRUE)

# Explicamos todas las expresiones regulares:
# ^: inicio de linea
# \\d: aparece un dígito
# \\s: aparece un espacio en blanco
# +: una o más veces
```

Como podemos observar en la tabla \@ref:tabla-combinaciones, las combinaciones más comunes son brotes tiernos maxi y queso lonchas cabra (comprados 16 veces).

\newpage

12. ¿Hay estacionalidad en plátanos? (se compran más en cierta fecha del año)

Esta pregunta busca detectar si existe una estacionalidad en la compra de plátanos, es decir, si hay meses específicos en los que se compran más plátanos que en otros. Para analizar esto, primero se filtran las líneas que contienen la palabra "plátano" (ignorando mayúsculas y minúsculas). Luego, se identifican los tickets (archivos) que contienen estos productos. A partir de esos tickets, se recuperan las fechas asociadas a cada compra de plátanos, que normalmente se encuentran en la línea 5 de cada ticket, y se extrae la fecha en formato texto para convertirla en un formato de fecha válido en R.

Una vez que se tiene la fecha, se necesita conocer la cantidad de plátanos comprados. Esto se logra localizando la línea inmediatamente después de donde aparece la palabra "plátano", ya que allí suele aparecer la cantidad en kilogramos, el precio por kilo y el precio total. Esta información se extrae con expresiones regulares y se separa en columnas llamadas cantidad, precio(kg) y precio(total). A continuación, se limpian los datos eliminando la unidad "kg", reemplazando las comas por puntos, y convirtiendo la cantidad a formato numérico. Después, se transforma la fecha para separar el año y el mes, y se agrupa por "año-mes" para sumar cuántos kilos de plátanos se vendieron en cada periodo. Finalmente, se genera un gráfico de puntos para visualizar si existe algún patrón o tendencia estacional en la compra de plátanos a lo largo del tiempo.

```{r figura-platano, fig.cap="Cantidad de plátanos comprados por mes"}
#Ya tenemos un df con las fechas, ahora creamos otro con todos los tickets que tienen plátanos.
platanos <- df_lineas %>% filter(str_detect(tolower(texto), "platano"))

#Vamos a ver cuantos kilos se compran de platanos en cada fecha, así que vamos a guardar en un vector las líneas de los archivos que contienen plátanos.
archivo_platanos <- platanos %>% select(archivo) #filtramos los nombres
archivo_platanos <- as.vector(archivo_platanos$archivo) #Convertir a vector

#Con el vector de los archivos creamos un df de las fechas en las que se comparon plátanos
df_fechas_platanos <- df_lineas %>% filter(linea == "5") %>% right_join(data.frame(archivo = archivo_platanos), by = "archivo")

#Filtramos para quedarnos solo con las fechas en formato texto
df_fechas_platanos <- df_fechas_platanos %>%  mutate(fecha = str_extract(texto, "\\b\\d{2}/\\d{2}/\\d{4}\\b" # Explicamos todas las expresiones regulares: \\b: marca el comienzo o el final de una palabra, \\d: aparece un dígito, \\s: aparece un espacio en blanco, +: una o más veces, \\d{2}: exactamente dos dígitos (los decimales, como "00"), \\d{4}: exactamente cuatro dígitos)) %>% select(-texto)
                                                                         )) %>% select(-texto)

#Guardamos la fecha en el df de platanos
platanos$fecha <- df_fechas_platanos$fecha
platanos$fecha <- as.Date(platanos$fecha, format = "%d/%m/%Y") #Convertimos en formato fecha

#Filtramos para hallar los kilos de plátanos en cada compra
vector_platanos <- which(str_detect(tolower(df_lineas$texto), "platano")) #Crea un vector con las filas en las que aparecen los plátanos

#Encontramos la linea donde aparece la cantidad de plátanos (en kg) comprada
filas_kilos_platanos <- vector_platanos + 1

#Añadimos las líneas de los kilos al df
platanos$info <- df_lineas %>% slice(filas_kilos_platanos)%>%pull(texto)

#Arreglamos el df para quedarnos con lo que necesitamos
platanos_limpio <- platanos %>% extract(texto, into = c("unidades", "producto"), 
                                        regex = "^[ ]*([0-9]+)[ ]+([A-Z]+)$") %>% #Opcional que empiecen con espacio, seleccionamos uno o más números del 0 al 9 que haya uno o más espacios y que acabe con uno o más caracteres de la A a la Z para seaparar en dos columnas: unidades y producto

  extract(info, into = c("cantidad", "precio(kg)", "precio(total)"), 
          regex = " {1,}([0-9,]+ kg)[ ]+([0-9,]+ €/kg)[ ]+([0-9,]+)$") %>% #Que empiece con uno o más espacios, que contenga uno o más números del 0 al 9 separados por una "," " " kg que haya uno o más espacios contenga contenga uno o más números del 0 al 9 separados por una "," " " €/kg y que acabe con uno o más números del 0 al 9 separados por una "," para separarlo en 3 columnas: cantidad, precio(kg), precio(total)

  select(producto, fecha, cantidad) %>% #Seleccionamos lo que nos interesa
  
  mutate(cantidad = str_replace(cantidad, " kg", "")) %>% #Eliminamos kg
  
  mutate(cantidad = str_replace(cantidad, ",", ".")) %>% #Cambiamos "," por "." para convertirlo después a numérico
  
  mutate(cantidad = as.numeric(cantidad)) #Convertimos a numerico

#Separamos fechas en mes y año para agrupar y obtener las cantidades totales por mes y año
platanos_limpio <- platanos_limpio %>% mutate(fecha = as.character(fecha)) %>% separate(fecha, into = c("anyo", "mes", "dia"), sep = "-") %>% unite(col = "anyo-mes", c(anyo,mes), sep = "-") %>% select(`anyo-mes`, cantidad) %>% group_by(`anyo-mes`) %>% summarize(cantidad_total = sum(cantidad)) %>% arrange(`anyo-mes`)

#Graficamos
grafico_platanos <- platanos_limpio %>% ggplot(aes(x = `anyo-mes`, y = cantidad_total)) + geom_point(aes(color = `anyo-mes`)) + labs(title = "Kg de plátanos comprados por cada mes y año")
grafico_platanos



```

Como se puede comprobar en la gráfica \@ref:figura-platanos se compran más platanos en los meses de enero, febrero y marzo (es decir, en invierno), por tanto, los plátanos tienen estacionalidad.

\newpage

13. ¿Cuántos productos se compran por ticket, en promedio?

Esta pregunta calcula cuántos productos se compran, en promedio, por ticket. Para ello, se agrupan las líneas por ticket y se identifica hasta qué punto del texto aparecen los productos, usando como referencia las palabras "TOTAL" o "PARKING".

Luego, se cuentan las líneas que representan productos, detectando aquellas que empiezan con un número seguido de un espacio (por ejemplo: “1 LIMPIADOR 1,50”), que es el formato típico en los tickets de Mercadona.

Una vez contado el número de productos en cada ticket, se calcula el promedio total usando la función mean(). Además, se crea un gráfico de barras que muestra la frecuencia de tickets según la cantidad de productos que contienen.

```{r}
# Paso 1: Contar los productos por ticket
df_productos <- df_lineas %>%
  group_by(archivo) %>%
  mutate(
    # Detectar la primera línea con "TOTAL" o "PARKING"
    linea_fin = min(
      c(
        linea[str_detect(texto, regex("TOTAL", ignore_case = TRUE))],
        linea[str_detect(texto, regex("PARKING", ignore_case = TRUE))]
      ),
      na.rm = TRUE
    ),
    linea_fin = ifelse(is.infinite(linea_fin), max(linea), linea_fin),
    
    # Marcar si es línea de producto real
    es_producto = linea >= 12 & linea < linea_fin & str_detect(str_trim(texto), "^\\d+\\s")
  ) %>%
  summarise(num_productos = sum(es_producto), .groups = "drop")

# Paso 2: Calcular el promedio de productos por ticket
promedio_productos_por_ticket <- mean(df_productos$num_productos)

# Mostrar el resultado
promedio_productos_por_ticket

# Crear el gráfico de barras para el número de productos por ticket
ggplot(df_productos, aes(x = num_productos)) +
  geom_bar(fill = "black") +
  labs(title = "Distribución de productos por ticket", 
       x = "Número de productos por ticket", 
       y = "Frecuencia") +
  theme_minimal()
```

Como vemos en el resultado, en promedio se compran 16 productos por ticket.

\newpage

14. ¿Cuál es el importe medio por ticket? ¿Cuál es el ticket más caro registrado? ¿Y el más barato?

Esta pregunta analiza los importes de los tickets para saber cuánto se gasta en promedio y detectar el ticket más caro y el más barato.

Primero se agrupan los datos por ticket y se identifica el método de pago (tarjeta, efectivo o desconocido). Luego se localiza la línea que contiene “TOTAL (€)” y se extrae el importe total del ticket.

Con esos datos, se calcula el importe medio por ticket y se muestra un histograma para ver la distribución de importes. Finalmente, se busca qué ticket tiene el importe más alto y cuál tiene el más bajo.

```{r}
# Paso 1:Calcular el importe medio por ticket y representar
resumen_tickets <- df_lineas %>%
  #Agrupamos todas las líneas que pertenecen al mismo ticket.
  group_by(archivo) %>%  
  #Determinamos el tipo de pago
  summarise(Metodo_Pago = case_when(
    
#Buscamos en todas las líneas de texto del ticket si alguna contiene Tarjeta Bancaria o Efectivo (da igual que este en mayúsculas o minúsculas) y lo asignamos a       Efectivo o a Tarjeta.
  any(str_detect(texto, regex("TARJETA BANCARIA | TARJ. BANCARIA | TARJ BANCARIA", ignore_case = TRUE))) ~ "Tarjeta",
  any(str_detect(texto, regex("EFECTIVO|PAGO.?EFECTIVO|PAGADO EN EFECTIVO", ignore_case = TRUE))) ~ "Efectivo",
  
  #Si no se cumple ninguna condición anterior se asigna "Desconocido" como método de pago.
  TRUE ~ "Desconocido"
),
    # Extraemos el importe total del ticket
    Importe_Total = {
      #Busca la linea de texto que contiene la frase "TOTAL (€)"
      total_linea <- texto[str_detect(texto, "TOTAL \\(€\\)")] 
      #Extrae de esa línea un patrón que representa un número con una coma como separador decimal
      importe <- str_extract(total_linea, "\\d+,\\d{2}")         
      #Si se encuentra un importe, reemplaza la coma por un punto para convertirlo a formato numérico. Si no se encuentra la línea del total o el patrón del importe, asigna       un valor NA.
      if (!is.na(importe)) {
        as.numeric(str_replace(importe, ",", "."))} 
      else {
        #Si no se encuentra, dejamos un valor NA
        NA_real_}}
  ) %>%
  #Eliminamos aquellos tickets donde no se detectó importe total
  filter(!is.na(Importe_Total))
importe_medio_por_ticket <- mean(resumen_tickets$Importe_Total, na.rm = TRUE)
ggplot(resumen_tickets, aes(x = Importe_Total)) +
  geom_histogram(binwidth = 5, color = "black") +  # Puedes ajustar el binwidth para cambiar la granularidad
  labs(title = "Histograma del Importe por Ticket",
       x = "Importe Total del Ticket (€)",
       y = "Frecuencia") +
  theme_minimal()
importe_medio_por_ticket

# Paso 2: Encontrar el ticket más caro
ticket_mas_caro <- resumen_tickets %>% slice_max(Importe_Total, n = 1)
ticket_mas_caro

# Paso 3: Encontrar el ticket más barato
ticket_mas_barato <- resumen_tickets %>% slice_min(Importe_Total, n = 1)
ticket_mas_barato
```

Como vemos en el resultado, el importe medio por ticket es de 46€. El ticket más caro registrado es: 20240323 Mercadona 234,20.pdf y el más barato es: 20241227 Mercadona 0,43 €.pdf.

\newpage

15. ¿Cuál es la cantidad total de dinero que se obtiene en impuestos cuando se venden alimentos con un 10% de IVA? ¿Y con un 21% y un 5%?

Queremos calcular la cantidad total de dinero recaudado en concepto de impuestos (IVA) a partir de los tickets de compra proporcionados. En este caso, nos piden centrarnos solo en 3 tipos de IVA (21%, 10% y 5%).

Para poder realizar este análisis, primero debemos partir del dataframe original (df_lineas). Como los datos del IVA se pueden encontrar en diferentes lineas utilizaremos una expresión regular que detecte información sobre el IVA. Esto lo haremos mediante la función str_detect() de la librería stringr. Además usaremos una serie de funciones para transformar y organizar los datos.

```{r}
df_IVA<-df_lineas %>% 
  #seleccionamos las filas del dataframe que coincidan con la expresión regular.
  filter(str_detect(texto, "^\\s*\\d{1,2}%?\\s+\\d+[,.]\\d{2}\\s+\\d+[,.]\\d{2}")) %>%
  
  #"^\\s*\\d{1,2}%?\\s+\\d+[,.]\\d{2}\\s+\\d+[,.]\\d{2}" es la expresión regular:
          #"^" Asegura que el patrón comience al principio de línea.

          #"\\s*" Permite que la línea pueda comenzar con espacios.
  
          #"\\d{1,2}" Captura uno o dos dígitos (como 5, 10 o 21).
          
          #"%?" Detecta el número o el número y el porcentaje.

          #"\\s+" Requiere al menos un espacio entre el porcentaje y el siguiente número.

          #"$" Indica el final de la línea.
  mutate(
  #Elimina espacios innecesarios al principio, final y entre palabras
  texto=str_squish(texto),
  
  #Extraemos los componentes porcentaje, base y cuota con la expresión regular.
  porcentaje = str_extract(texto, "^\\d{1,2}" # Expresiones regulares: ^:inicio de linea, \\d{1,2} : debe haber entre 1 o 2 cifras, 
                           ),
  base = str_extract(texto, "(?<=\\s)\\d+[,.]\\d{2}(?=\\s+\\d+[,.]\\d{2}$)" # Expresiones regulares: (?<=\\s): asegura que antes haya al menos un espacio, \\d+: uno o más dígitos, [,.]: punto o coma como separador decimal, \\d{2}: exactamente dos dígitos, $:fin de linea
                     ),
  cuota = str_extract(texto, "\\d+[,.]\\d{2}$" # Expresiones regulares: \\d+: uno o más dígitos, [,.]: punto o coma como separador, \\d{2}: exactamente dos dígitos, $:fin de linea
                      )
  ) %>% 
  
  #Convertimos los strings en valores numéricos
  mutate(
    #Se elimina el símbolo %
    porcentaje = as.numeric(str_replace(porcentaje, "%", "")),
    #Se reemplaza comas por puntos en decimales
    base = as.numeric(str_replace(base, ",", ".")),
    cuota = as.numeric(str_replace(cuota, ",", "."))
  ) %>%
  #Seleccionamos las columnas que nos interesan
  select(archivo, linea, porcentaje, base, cuota)

```

Ya hemos creado el dataframe que contiene toda la información del IVA proporcionada en los tickets. Ahora a partir de este agruparemos todas las líneas por porcentaje de IVA y sumaremos todas las cuotas asociadas a los tipos de IVA. Una vez lo tengamos utilizaremos la función filter() para así centrarnos únicamente en los tres tipos de IVA que queremos analizar, que son IVA del 5%, 10% y 21%.

```{r tabla-TiposIVA}

total_TipoIVA <- df_IVA %>%
  #Agrupamos juntas todas las filas con el mismo porcentaje de IVA.
  group_by(porcentaje) %>%
  summarise(
    #Para cada grupo de porcentaje de IVA, calcula la suma de los valores en la columna cuota
    Cuota= sum(cuota, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  #Ordenamos los resultados de mayor a menos porcentaje de IVA.
  arrange(desc(porcentaje))

#Mostrar solo los tipos que nos interesan, en este caso solo el 21%, 10% y 5%
IVA_filtrado <- total_TipoIVA %>%
  filter(porcentaje %in% c(21, 10, 5))

#Mostramos el resultado mediante una tabla.
kable(IVA_filtrado, caption = "Total de IVA por tipo de porcentaje")
```

La tabla \@ref:tabla-TiposIVA revela que la mayor recaudación por IVA, con un total de 666.01€, corresponde a los productos gravados al 10%. En cambio, los productos con un IVA del 21% generaron una recaudación de 256.74€, mientras que aquellos con un IVA del 5% aportaron 8.21€.

Por último, queremos verificar si se han tenido en cuenta todos los tickets y que no se haya perdido ningún dato en el proceso de extracción del IVA. Podemos comparar el número total de tickets únicos en el dataframe original (df_lineas) con el número de tickets para los cuales se pudo extraer distinta información del IVA en el dataframe lineas_IVA.

```{r}
#Aplicamos la función unique() seleccionando en el data frame la columna archivo, esta función obtiene los valores únicos. Además con la función length nos muestra la cantidad de ticket distintos.
total_tickets <- length(unique(df_lineas$archivo))
tickets_con_IVA <- length(unique(df_IVA$archivo))

cat("Tickets totales:", total_tickets, "\n")
cat("Tickets con IVA:", tickets_con_IVA, "\n")
```

Como podemos ver, ambos números son iguales (total de tickets únicos y tickets con el IVA extraido), entonces no hay ningún dato perdido.

\newpage

16. ¿A qué horas se suele ir más a comprar en los supermercados? ¿Cuáles son las que menos?

Queremos saber qué horas del día tienen mayor y menor afluencia en supermercados. Para ello, necesitamos extraer la hora de compra registrada en cada ticket.

Dado que la hora puede encontrarse en diferentes líneas dentro del ticket, aplicamos una expresión regular que detecta el formato "hh:mm". Esto se realiza mediante la función str_extract() de la librería stringr. Además usamos una serie de funciones para transformar y organizar los datos.

Este proceso nos permite construir un nuevo data frame (df_horas) con la hora de compra de cada ticket.

```{r}
df_horas <- df_lineas %>%
  mutate(
    #buscamos una hora en formato "hh:mm" usando expresiones regulares.
    hora_texto = str_extract(texto, "\\b\\d{1,2}:\\d{2}\\b") 
        
    #"\\b\\d{1,2}:\\d{2}\\b" es la expresión regular:
    
              #"\\b" significa el límite de palabra, se asegura que la coincidencia esté al inicio o al final de una palabra.
                  
              #"\\d{1,2}" Coincide con 1 o 2 dígitos (para horas como 8 o 14)
                  
              #":" Dos puntos, separa la hora y los minutos
              
              #"\\d{2}" Coincide con exactamente 2 dígitos (para minutos como 05 o 41).    
    
              #"\\b" es el límite de palabra (el final)
  )%>% 
  
  #!is.na() crea un vector donde si hay valores en hora_texto es TRUE y donde no haya es FALSE. Utilizando la función filter() filtramos las líneas TRUE, en las que hay       valores. 
  filter(!is.na(hora_texto)) %>%
  #Utilizamos group_by que agrupa todas las líneas que pertenecen al mismo ticket.
  group_by(archivo)%>%
  #Dentro de cada agrupación de ticket (que ahora solo contiene las líneas con hora), selecciona la primera de esas líneas.
  slice_head(n=1)%>%
  mutate(
     #la función hour() extrae solo la hora numérica (selecciona 14 en vez de 14:41).La función hm() convierte la hora como texto a un objeto de tiempo.
     hora = hour(hm(hora_texto))) %>%
     #Seleccionamos la hora y el nombre del archivo.
     select(archivo, hora)
```

A partir del nuevo data frame (df_horas) contamos con que frecuencia de tickets por cada hora del día y lo visualizamos en un gráfico de barras. Así, podemos identificar con claridad las horas pico de afluencia y las horas más tranquilas.

```{r figura-Frecuenciahoras}
#Utilizamos la función count() (aplicandola al data frame df_horas). Esta función cuenta cuántos tickets hay por cada hora del día (de 0 a 23) 
FrecuenciaHora_supermercado<- df_horas %>% count(hora)

#Realizamos una gráfico que muestre qué hora es más frecuente:
#Utilizamos la función ggpplot() y geom_bar() que crean un gráfico de barras.
ggplot(FrecuenciaHora_supermercado, aes(x = hora, y = n)) +
  geom_bar(stat = "identity", fill = "lightgreen") +
  labs(
    title = "Frecuencia de compras por hora del día",
    x = "Hora (24h)",
    y = "Número de tickets"
  ) +
  #Esta función muestra todas las horas del 0 al 23 en el eje X.
  scale_x_continuous(breaks = 0:23) +
  #Esta función aplica un diseño mucho más limpio y simple ya que elimina el fondo gris, pone las líneas de las cuadrículas más ligeras etc.
  theme_minimal()
```

El gráfico de barras \@ref:figura-Frecuenciahoras muestra que las horas de mayor afluencia en el supermercado son las 20h y las 19h, con poco más de 50 y 40 tickets registrados respectivamente. En cambio, las horas de menor afluencia, sin considerar el horario de cierre (8h y 22h), son las 10h y las 9h, con menos de 5 tickets a las 10h y menos de 10 a las 9h.

Por último, queremos verificar si se han tenido en cuenta todos los tickets y que no se haya perdido ningún dato en el proceso de extracción de la hora. Podemos comparar el número total de tickets únicos en el dataframe original (df_lineas) con el número de tickets para los cuales se pudo extraer una hora en el dataframe df_horas.

```{r}
#Aplicamos la función unique() seleccionando en el data frame la columna archivo, esta función obtiene los valores únicos. Además con la función length nos muestra la cantidad de ticket distintos.
length(unique(df_lineas$archivo))

#Ahora seleccionamos las columnas del nuevo dataframe donde se encuentra solo las horas de cada ticket.
nrow(df_horas)
```

Como podemos ver, ambos números son iguales (total de tickets únicos y tickets con hora extraída), entonces no hay ningún dato perdido.

\newpage

17. ¿Qué método de pago es más frecuente en los tickets: tarjeta o efectivo? Muéstralo mediante un box plot ¿Cuánto se ha gastado en total con cada método de pago?

Nos piden averiguar cual es el método de pago que más se repite: efectivo o tajeta.

En este caso se repite el hecho de que la forma de pago puede encontrarse en diferentes líneas dentro del ticket, por eso vamos a aplicar la funcion str_detect() para ver si es Tarjeta o Efectivo. Además queremos calcular también el importe total de cada método de pago.

```{r}
resumen_tickets <- df_lineas %>%
  #Agrupamos todas las líneas que pertenecen al mismo ticket.
  group_by(archivo) %>%  
  #Determinamos el tipo de pago
  summarise(Metodo_Pago = case_when(
    
#Buscamos en todas las líneas de texto del ticket si alguna contiene Tarjeta Bancaria o Efectivo (da igual que este en mayúsculas o minúsculas) y lo asignamos a       Efectivo o a Tarjeta.
  any(str_detect(texto, regex("TARJETA BANCARIA | TARJ. BANCARIA | TARJ BANCARIA", ignore_case = TRUE))) ~ "Tarjeta",
  any(str_detect(texto, regex("EFECTIVO|PAGO.?EFECTIVO|PAGADO EN EFECTIVO", ignore_case = TRUE))) ~ "Efectivo",
  
  #Si no se cumple ninguna condición anterior se asigna "Desconocido" como método de pago.
  TRUE ~ "Desconocido"
),
    # Extraemos el importe total del ticket
    Importe_Total = {
      #Busca la linea de texto que contiene la frase "TOTAL (€)"
      total_linea <- texto[str_detect(texto, "TOTAL \\(€\\)")] 
      #Extrae de esa línea un patrón que representa un número con una coma como separador decimal
      importe <- str_extract(total_linea, "\\d+,\\d{2}")         
      #Si se encuentra un importe, reemplaza la coma por un punto para convertirlo a formato numérico. Si no se encuentra la línea del total o el patrón del importe, asigna       un valor NA.
      if (!is.na(importe)) {
        as.numeric(str_replace(importe, ",", "."))} 
      else {
        #Si no se encuentra, dejamos un valor NA
        NA_real_}}
  ) %>%
  #Eliminamos aquellos tickets donde no se detectó importe total
  filter(!is.na(Importe_Total))  
```

Tenemos ya el dataframe resumen_tickets que contiene solo las líneas de texto que mencionan el método de pago. A partir de este dataframe calcularemos el importe total de cada método de pago.

```{r tabla-tipospago}
#Agrupamos por método de pago para ver cuánto se ha gastado con cada uno
totales_por_metodo <- resumen_tickets %>%
  group_by(Metodo_Pago) %>%
  #Sumamos los importes totales por tipo de pago
  summarise(Total_Gastado = sum(Importe_Total)) %>% 
  #Ordenamos de mayor a menor gasto
  arrange(desc(Total_Gastado))  

# Mostramos e el total gastado por método de pago
kable(totales_por_metodo, caption = "Importe total de cada método de pago")
```

Como se puede observar en la tabla \@ref:tabla-tipospago cada ticket ha coincidido en el método de pago, todos han sido pagados con tarjeta. También vemos que el importe total de todos los tickets es 13.649,8€.

\newpage

# Conclusión

A lo largo de este proyecto, se ha desarrollado una herramienta funcional y automatizada en R para la lectura, limpieza, estructuración y análisis de tickets de compra en formato PDF, concretamente de supermercados Mercadona. Este sistema permite transformar documentos no estructurados en un conjunto de datos ordenado y analizable, lo que constituye un paso esencial en el procesamiento de información real proveniente del ámbito del consumo diario.

Gracias al uso de librerías como pdftools, dplyr y stringr, ha sido posible extraer con precisión la información clave de los tickets: desde los productos comprados hasta sus cantidades, precios, fechas y patrones de compra. Además, se han podido explorar aspectos interesantes como las combinaciones de productos más frecuentes o el posible comportamiento estacional en la compra de ciertos alimentos, como los plátanos.

Este trabajo no solo demuestra el valor del análisis de datos aplicado a la vida cotidiana, sino que también sienta las bases para posibles desarrollos futuros. Por ejemplo, se podrían integrar tickets de otros supermercados, analizar tendencias de precios a lo largo del tiempo o incluso construir recomendaciones personalizadas para consumidores.

En resumen, este proyecto muestra cómo la tecnología y el análisis de datos pueden ayudar a entender mejor los hábitos de consumo, ofrecer información útil para la toma de decisiones y fomentar una gestión más inteligente del gasto doméstico.

#Referencias

##Referncias a tablas:

-   
